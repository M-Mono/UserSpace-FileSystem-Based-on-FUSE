bug 001:
	调用 int open(pathname, flag) 时, 若打开标志 flag 与稍后的操作
	不相容 (例如以 O_RDONLY 打开, 稍后却调用了 write(); 或以 
	O_WRONLY 打开, 稍后却调用了 read()), 当 open() 返回后, fuse
	会紧接着调用 flush() 与 release(), release() 会释放文件描述符占
	用的项, 使得后续的以 文件描述符作为参数的系统调用 (例如 write())
	失败.
	其实这并不是一个 bug, 而是系统调用的共性. 在其他文件系统中测试, 也
	可以出现同样的结果: 稍后的操作与之前的打开方式相冲突, 系统就会自动
	关闭文件描述符.

read of fuse:
    fuse 会自动对 read() 的数据量与偏移位置进行页对齐. 例如, 从偏移位置
    3 读 100 个字节, fuse 会自动调整为从偏移位置 0 读取 16384 (即 16k)
    个字节; 从偏移位置 5000 读 4097, 会被 fuse 调整为 从偏移位置 4096
    读 8192 个字节.

    但是同样的情况却不适用于 write(). 如果我们从偏移位置 87 写 23 个字节,
    fuse 不会自动对偏移位置与写数据量进行页对齐, 而是直接将 "87" 与 "23"
    传递给用户的 write(). 如果我们从偏移位置 4098 写 5083 个字节, fuse 
    调用两次用户实现的 write(), 第1次 offset = 4098, size = 4094;
    第2次 offset = 8192, size = 989.
