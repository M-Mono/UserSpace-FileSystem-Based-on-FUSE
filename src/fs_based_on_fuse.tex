\documentclass[nofonts, titlepage]{ctexart}
\usepackage{geometry}
\usepackage{fontspec}
\usepackage{xeCJK}
\usepackage{caption}
\usepackage{amssymb}
\usepackage{hyperref}
\geometry{%
    bottom = 2cm,
    outer = 2.5cm,
    inner = 2.5cm,
}
\setCJKmainfont{AR PL UKai CN}
\setCJKsansfont{AR PL UKai CN}
\setCJKmonofont[Scale=0.9]{AR PL UMing CN}
\setmainfont{FreeSerif}
\setsansfont{FreeSans}
\setmonofont{FreeMono}

\renewcommand\labelitemii{\tiny{$\square$}}

\hypersetup{
    pdfborder=0 0 0,
    colorlinks=false,
}

\title{基于 fuse 的文件系统设计与实现}
\author{吴周辉 \\ 中国科学院计算技术研究所}

\begin{document}

\maketitle
\tableofcontents

\section{FUSE 背景与资料}\label{fuse-ux80ccux666fux4e0eux8d44ux6599}

\subsection{fuse-1.3 的工作方式}

\begin{center}
\includegraphics[width=14cm]{./images/./FUSE_structure.svg.png}
\captionof{figure}{fuse-1.3 结构图及其工作流程}
\label{fig:fuse_structure}
\end{center}

\subsubsection{内核模块}\label{ux5185ux6838ux6a21ux5757}

内核模块由两个部分组成, 第一个是位于 \texttt{kernel/dev.c} 的
\texttt{proc} 文件系统, 第 二个是位于 \texttt{kernel/file.c},
\texttt{kernel/inode.c}, \texttt{kernel/dir.c} 的文件系统 调用.

\texttt{kernel/file.c}, \texttt{kernel/inode.c}, \texttt{kernel/dir.c}
中的所有系统调用都会 调用 \texttt{request\_send()}, 或者是
\texttt{request\_send\_noreply()}, 又或者是
\texttt{request\_send\_noblock()}. 大多数系统调用 (有2个除外) 调用的是
\texttt{request\_send()}. \texttt{request\_send()} 将请求放入
``请求队列'' (\texttt{fc-\textgreater{}pending}), 等待响应.
\texttt{request\_send\_noreply()} 不会等待响应,
\texttt{request\_send\_noblock()} 不会阻塞, 除此之外, 这两个函数与
\texttt{request\_send()} 的功能相同.

\texttt{proc} 文件系统对应于 \texttt{/dev/fuse} 的文件 I/O 请求.
\texttt{fuse\_dev\_read()} 处理 文件的读操作, 并将 ``请求队列''
的命令返回给主调程序. \texttt{fuse\_dev\_write()} 处理文件的写操作,
该函数接收要被写入的数据, 将其放入 \texttt{req-\textgreater{}out}
结构中, 这些要被写入的数据会通过 ``请求队列'' 与
\texttt{request\_send()} 返回给系统调用.

\subsubsection{fuse 库函数}\label{fuse-ux5e93ux51fdux6570}

\begin{itemize}
\item
  当你的用户态程序调用 \texttt{fuse\_main()} (\texttt{lib/helper.c}) 时,
  \texttt{fuse\_main()} 开始 解析传递给程序的参数, 然后调用
  \texttt{fuse\_mount()} (\texttt{lib/mount.c}).
\item
  \texttt{fuse\_mount()} 创建一对 UNIX 域套接字, 然后 \texttt{fork()} 并
  \texttt{exec()} \texttt{fusermount} (\texttt{util/fusermount.c}),
  通过环境变量 \texttt{FUSE\_COMMFD\_ENV} 将其中一个套接字传递 给
  \texttt{fusermount}.
\item
  \texttt{fusermount} (\texttt{util/fusermount.c}) 先确定 fuse
  模块已加载进内核. 然后, \texttt{fusermount} 打开 \texttt{/dev/fuse}
  并将文件描述符通过 UNIX 域套接字发回给 \texttt{fuse\_mount()}.
\item
  \texttt{fuse\_mount()} 收到 \texttt{/dev/fuse}
  的文件描述符后将其返回给 \texttt{fuse\_main()}.
\item
  \texttt{fuse\_main()} 调用 \texttt{fuse\_new()} (\texttt{lib/fuse.c}),
  后者分配一个结构体 \texttt{struct fuse},
  该结构用来存放并维护文件系统数据的一个缓冲映像.
\item
  最后, \texttt{fuse\_main()} 或者调用 \texttt{fuse\_loop()}, 又或者是
  \texttt{fuse\_loop\_mt()} (\texttt{lib/fuse.c}), 这两个函数都会从
  \texttt{/dev/fuse} 中读取用户文件系统从内核收 到的请求 (比如
  \texttt{read}, \texttt{stat} 等), 然后调用
  \texttt{struct fuse\_operations} 中对应 的用户态函数,
  函数调用的结果会写回到 \texttt{/dev/fuse}, 通过它返回给内核.
\end{itemize}

\subsection{FUSE 文件系统}
\label{fuse-ux6587ux4ef6ux7cfbux7edfux7b80ux4ecb}

\subsubsection{定义}\label{ux5b9aux4e49}

\begin{itemize}
\item
  用户空间文件系统\\一种文件系统,
  它的数据与元数据由一个普通的用户态进程提供. 该文件系统可以
  通过内核接口 (系统调用) 访问.
\item
  文件系统守护进程\\提供文件系统的数据与元数据的进程
\item
  非特权挂载 (或 用户挂载)\\一个被非特权用户 (非 root 用户)
  挂载的用户空间文件系统. 文件系统守护进程的
  特权级是执行挂载操作的用户的特权级. \textbf{注意}: 这与
  \texttt{/etc/fstab} 的 \texttt{user} 选项不同,
  该选项允许一个普通用户挂载文件系统, 在这里我们不讨论
  \texttt{/etc/fstab}.
\item
  挂载属主\\执行挂载操作的用户.
\item
  用户\\执行文件系统操作的用户.
\end{itemize}

\subsubsection{FUSE 简介}\label{ux4ec0ux4e48ux662f-fuse}

FUSE 是一个用户空间文件系统框架. 它由一个内核模块 (\texttt{fuse.ko}),
用户空间 库函数 (\texttt{libfuse.*}), 一个挂载实用程序
(\texttt{fusermount}) 组成.

FUSE 一个最重要的特点是允许安全的非特权挂载. 这个特点开启了文件系统
的一个新的用法. 一个好的例子是 sshfs: 一个安全的, 使用 sftp 协议的网络
文件系统.

用户空间的库函数与实用程序可以从 FUSE 的首页获取
\url{http://fuse.sourceforge.net}.

\subsubsection{文件系统类型}\label{ux6587ux4ef6ux7cfbux7edfux7c7bux578b}

传递给 \texttt{mount}(2) 的文件系统类型参数可以是以下两种:
\begin{itemize}
    \item
\texttt{fuse}\\这是挂载 FUSE 文件系统的通常方式. 传递给 \texttt{mount}
系统调用的第一个参数可 以是任意的字符串, 内核不会对该字符串进行解释.
\item 
\texttt{fuseblk}\\文件系统是基于块设备的. 传递给 \texttt{mount}
系统调用的第一个参数被内核解释 成设备名.
\end{itemize}

\subsubsection{挂载参数}\label{ux6302ux8f7dux53c2ux6570}

\begin{itemize}
\item
  \texttt{fd=N}\\用于用户空间文件系统与内核之间通信的文件描述符,
  该文件描述符必须事先通过 打开 \texttt{/dev/fuse} 获取.
\item
  \texttt{rootmode=M}\\文件系统根目录的访问权限, 以 8 进制表示.
\item
  \texttt{user\_id=N}\\挂载属主的用户 ID.
\item
  \texttt{group\_id=N}\\挂载属主的组 ID.
\item
  \texttt{default\_permissions}\\FUSE 默认不会检查文件访问权限,
  文件系统可以自由地实现自身的访问策略, 或者
  将工作交给底层的文件访问机制 (例如, 网络文件系统).
  这个选项开启权限检查, 根据文件的访问权限设置来限制用户的访问.
  这个选项通常与 \texttt{allow\_other} 选项 配合使用.
\item
  \texttt{allow\_other}\\这个选项解除了
  ``只有挂载文件系统的用户才有权利访问文件'' 的限制. 默认该 选项只对
  root 开放, 但这个限制可以通过 (用户空间的) 配置文件来移除.
\item
  \texttt{max\_read=N}\\\texttt{read} 操作一次所能读取的最大字节数,
  默认值是无限制. \textbf{注意}, 无论如何, \texttt{read}
  请求的大小最多被限制为 32 页 (在 i386 架构中是 128 字节).
\item
  \texttt{blksize=N}\\设置文件系统的块大小. 默认值是 512. 这个选项只对
  \texttt{fuseblk} 类型的文件 系统有效.
\end{itemize}

\subsubsection{控制文件系统}\label{ux63a7ux5236ux6587ux4ef6ux7cfbux7edf}

这里有一个 FUSE 的控制文件系统, 可以通过下面这个命令挂载:

\begin{verbatim}
mount -t fusectl none /sys/fs/fuse/connections
\end{verbatim}

将它挂载到 \texttt{/sys/fs/fuse/connections} 是为了向下兼容.

在控制文件系统中, 每一个连接都对应有一个目录, 目录用互不相同的数字命名.

对每一个连接, 它对应的目录中都至少存在这两个文件:

\begin{itemize}
\item
  \texttt{waiting}\\等待被传送到用户空间,
  或等待被文件系统守护进程处理的请求个数. 如果文件 系统没有活动在进行,
  而 \texttt{waiting} 的内容不为零, 那么肯定是文件系统被挂 起,
  或者是发生了死锁.
\item
  \texttt{abort}\\往这个文件写任何数据都会终止文件系统连接,
  此时等待中的请求都会被终止并返回 一个错误, 新请求也会如此.
\end{itemize}

只有挂载属主才会写或读这些文件.

\subsubsection{中断文件系统操作}\label{ux4e2dux65adux6587ux4ef6ux7cfbux7edfux64cdux4f5c}

如果一个正在发送 FUSE 文件系统请求的进程被某个信号中断了,
会发生下面几件事:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  如果请求还未被发送至用户空间\textbf{并且}信号是致命的
  (\texttt{SIGKILL}, 或者是未捕 捉的致命信号), 那么请求就会被移出队列,
  并马上返回.
\item
  如果请求还未被发送至用户空间\textbf{并且}信号是非致命的,
  那么就会为该请求设置 一个 \texttt{interrupted} 标记.
  当请求成功传送到用户空间, 并且这个标记被设置, 一 个 \texttt{INTERRUPT}
  请求会被排入队列.
\item
  如果请求已经被传送至用户空间, 那么一个 \texttt{INTERRUPT}
  请求会被排入队列.
\end{enumerate}

\texttt{INTERRUPT} 请求优先于其他请求,
所以用户空间文件系统会优先接收已排队的 \texttt{INTERRUPT} 请求.

用户空间文件系统可以完全忽略 \texttt{INTERRUPT} 请求, 也可以向请求的
\emph{来源} 发送 一个回复来提醒它发生了一个中断, 并将 \texttt{errno}
设置为 \texttt{EINTR}.

在处理原始请求与 \texttt{INTERRUPT} 之间可能存在竞争状态,
这时候有两种可能:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \texttt{INTERRUPT} 请求在原始请求之前被处理.
\item
  \texttt{INTERRUPT} 请求在原始请求得到响应之后被处理.
\end{enumerate}

如果文件系统无法找到原始请求, 它应该等待一定的时间, 和 (或) 等待一定数量
的新请求到来, 在这之后, 它应该向 \texttt{INTERRUPT} 请求返回
\texttt{EAGAIN} 错误. 在第 1 种情况
(指上面提到的两种可能的竞争状态中的第1种) 中, \texttt{INTERRUPT}
请求会被 重新排队, 在第 2 种情况下, \texttt{INTERRUPT} 的回复会被忽略.

\subsubsection{中断一个文件系统连接}\label{ux4e2dux65adux4e00ux4e2aux6587ux4ef6ux7cfbux7edfux8fdeux63a5}

文件系统无法响应是有可能的. 可能的原因包括:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  有缺陷的用户空间文件系统实现.
\item
  网络连接断开.
\item
  偶然性的死锁.
\item
  恶意的死锁.
\end{enumerate}

(关于第 3 点与第 4 点更多的信息请看后面的小节)

在任何一种情况下, 中断文件系统连接都是一种比较好的解决方案. 中断连接有下
面几种方案:

\begin{itemize}
\item
  杀死文件系统守护进程, 对第 1 种与第2 种情况有效.
\item
  杀死文件系统守护进程与所有的文件系统用户. 对所有情况有效, 除了某些恶意
  的死锁.
\item
  强制卸载 (\texttt{umount -f}). 对所有情况有效,
  但前提是文件系统仍然处于挂接 状态 (未被懒惰卸载).
\item
  通过 FUSE 控制文件系统 终止. 这是最有效的方案, 总能奏效.
\end{itemize}

\subsubsection{非特权挂载的工作方式}
\label{subsub:how_do_non_privileged_mounts_work}

因为 \texttt{mount()} 系统调用是一个特权操作, 所以需要
\texttt{fusermount} 的帮助, \texttt{fusermount} 的 SUID 为 root.

提供非特权挂载的目的是防止挂载属主利用该能力来危害系统. 为了做到这一点,
下面这些需求是显然的:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  挂载属主不能在被挂载文件系统的帮助下, 提升自己的权限.
\item
  挂载属主不能非法获取其他用户或超级用户的进程信息.
\item
  挂载属主不能向其他用户或超级用户的进程施加未期望的行为.
\end{enumerate}

\subsubsection{需求的满足}
\label{subsub:how_are_requirements_fulfilled}

\def\labelenumi{\Alph{enumi})}
\def\labelenumii{\arabic{enumii})}
\def\labelenumiii{\roman{enumiii})}
\begin{enumerate}
    \item
        挂载属主可以通过下面2种方式之一提升权限:
        \begin{enumerate}
            \item
                创建一个包含设备文件的文件系统, 然后打开该设备文件.\\
            \item
                创建一个包含 SUID 或 SGID 程序的文件系统, 然后运行该程序.
        \end{enumerate}

        解决方案是禁止打开设备文件, 在执行程序时忽略 SGID 与 SUID.
        为了达到这两个 目的, 对于非特权挂载, \texttt{fusermount} 总是为
        \texttt{mount} 设置添加 \texttt{nosuid} 与 \texttt{nodev} 这两个选项.

    \item
        如果有另外一个用户正在访问文件系统的文件或目录, 此时,
        为请求提供服务的 文件系统守护进程会记录下操作的执行顺序与时间.
        这些信息对挂载属主来说是不 可访问的,
        所以如果挂载属主知晓了其他用户的操作信息, 这种现象叫做
        \textbf{信息泄漏}.

        这个问题的解决方案在在 C) 的 2) 中介绍.

    \item
        挂载属主可以用多种方式向其他用户进程施加未期望的行为, 例如:
        \begin{enumerate}
            \item
                在一个文件或目录之上挂载文件系统, 而这个文件或目录对挂载属主来说
                是不可修改的 (或者只能做非常有限的修改).\\这一点可以用
                \texttt{fusermount} 解决. \texttt{fusermount} 检查挂载点的访问权限,
                只 有在挂载属主有权利对挂载点作无限制的修改 (对挂载点拥有写权限,
                挂载点没有 设置粘置位) 的前提下, 才允许挂载.
            \item
                即使情况 1) 被解决了, 挂载属主依然有能力改变其他用户进程的行为:
                \begin{enumerate}
                    \item
                        通过发起一个针对用户或整个系统的 DoS (拒绝服务攻击),
                        挂载属主可以减慢或无限期地推迟一个文件系统操作. 一个设置了 SUID
                        的程序锁住了一个系统文件,
                        然后该程序访问挂载属主的文件系统中的一个文件,
                        而这个访问可以被暂停, 于是 这就造成了系统文件被永远地锁住.
                    \item
                        用户可以创建大小不受限制的文件或目录, 或者是层次非常深的目录,
                        这会造成磁盘空间与内存被消耗殆尽, 同样会造成 DoS.
                \end{enumerate}
        \end{enumerate}
\end{enumerate}
解决 C/2 (以及 B) 的办法是禁止进程访问不受挂载属主控制的文件系统.
因为如果挂载属主可以 \texttt{ptrace} 一个进程, 它可以在不使用 FUSE
挂载的前提下, 完成上面提到的那些事情.
同样的条件也可以运用在检查一个进程是否允许访问 文件系统.

\textbf{注意}, 使用 \texttt{ptrace} 检查对 C/2/i 来说并不是必须的,
只需要作这个检查就 足够了:
查看挂载属主是否有足够的权限向访问文件系统的进程发送信号. 这是因为
\texttt{SIGSTOP} 可以达到类似的效果.

\subsubsection{条件限制的放宽}
\label{subsub:i_think_these_limitations_are_unacceptable}

如果系统管理员足够相信用户 (或者可以通过某些方式来保证),
确保系统进程永远 不会进入一个非特权挂载点, 那么可以使用
\texttt{user\_allow\_other} 配置选项来放宽最后一 条限制条件.
如果这个配置选项被设置了, 那么挂载属主可以设置 \texttt{allow\_other}
选项来禁止掉对其他用户进程的检查.

\subsubsection{内核--用户空间
接口}\label{ux5185ux6838ux7528ux6237ux7a7aux95f4-ux63a5ux53e3}

下面这张图展示了一个文件系统操作 (在这里是 \texttt{unlink}) 在 FUSE
中如何执行 ({\textbf{注意}, 这里的讨论是经过简化了的}):

\begin{verbatim}
|  "rm /mnt/fuse/file"               |  FUSE filesystem daemon
|                                    |
|                                    |  >sys_read()
|                                    |    >fuse_dev_read()
|                                    |      >request_wait()
|                                    |        [sleep on fc->waitq]
|                                    |
|  >sys_unlink()                     |
|    >fuse_unlink()                  |
|      [get request from             |
|       fc->unused_list]             |
|      >request_send()               |
|        [queue req on fc->pending]  |
|        [wake up fc->waitq]         |        [woken up]
|        >request_wait_answer()      |
|          [sleep on req->waitq]     |
|                                    |      <request_wait()
|                                    |      [remove req from fc->pending]
|                                    |      [copy req to read buffer]
|                                    |      [add req to fc->processing]
|                                    |    <fuse_dev_read()
|                                    |  <sys_read()
|                                    |
|                                    |  [perform unlink]
|                                    |
|                                    |  >sys_write()
|                                    |    >fuse_dev_write()
|                                    |      [look up req in fc->processing]
|                                    |      [remove from fc->processing]
|                                    |      [copy write buffer to req]
|          [woken up]                |      [wake up req->waitq]
|                                    |    <fuse_dev_write()
|                                    |  <sys_write()
|        <request_wait_answer()      |
|      <request_send()               |
|      [add request to               |
|       fc->unused_list]             |
|    <fuse_unlink()                  |
|  <sys_unlink()                     |
\end{verbatim}

给一个 FUSE 文件系统造成死锁有几种方式, 因为我们讨论的是非特权的用户空间
程序, 关于这些我们必须做些什么.

\subparagraph{情景 1 --
简单的死锁}\label{ux60c5ux666f-1-ux7b80ux5355ux7684ux6b7bux9501}

\begin{verbatim}
|  "rm /mnt/fuse/file"               |  FUSE filesystem daemon
|                                    |
|  >sys_unlink("/mnt/fuse/file")     |
|    [acquire inode semaphore        |
|     for "file"]                    |
|    >fuse_unlink()                  |
|      [sleep on req->waitq]         |
|                                    |  <sys_read()
|                                    |  >sys_unlink("/mnt/fuse/file")
|                                    |    [acquire inode semaphore
|                                    |     for "file"]
|                                    |    *DEADLOCK*
\end{verbatim}

解决方案是终止文件系统.

\subparagraph{情景 2 --
狡猾的死锁}\label{ux60c5ux666f-2-ux72e1ux733eux7684ux6b7bux9501}

这一个需要精心制作的文件系统. 这是上面情景的变形,
只有对文件系统的回调不是 显式的, 但这里的死锁是由页错误造成的.

\begin{verbatim}
|  Kamikaze filesystem thread 1      |  Kamikaze filesystem thread 2
|                                    |
|  [fd = open("/mnt/fuse/file")]     |  [request served normally]
|  [mmap fd to 'addr']               |
|  [close fd]                        |  [FLUSH triggers 'magic' flag]
|  [read a byte from addr]           |
|    >do_page_fault()                |
|      [find or create page]         |
|      [lock page]                   |
|      >fuse_readpage()              |
|         [queue READ request]       |
|         [sleep on req->waitq]      |
|                                    |  [read request to buffer]
|                                    |  [create reply header before addr]
|                                    |  >sys_write(addr - headerlength)
|                                    |    >fuse_dev_write()
|                                    |      [look up req in fc->processing]
|                                    |      [remove from fc->processing]
|                                    |      [copy write buffer to req]
|                                    |        >do_page_fault()
|                                    |           [find or create page]
|                                    |           [lock page]
|                                    |           * DEADLOCK *
\end{verbatim}

解决方案与上面的相同.

另一个问题是, 当写缓冲区正在被复制给请求, 那么请求不能被中断或终止.
这是因 为在请求返回之后, 复制操作的目标地址可能不再有效.

问题的解决办法是令复制操作成为一个原子操作, 当属于写缓冲区的页被
\texttt{get\_user\_pages()} 弄错时, 允许中断. 标志
\texttt{req-\textgreater{}flag} 指出复制正在发生,
终止操作会一直延迟到该标志被解除为止.

\subsection{我理解的 fuse
工作方式}\label{ux6211ux7406ux89e3ux7684-fuse-ux5de5ux4f5cux65b9ux5f0f}

我们以图 \ref{fig:fuse_structure} 为例, 说明一下 fuse 的工作流程.

\begin{itemize}
\item
  用户在 shell 中输入 \texttt{ls} 命令, shell \texttt{fork()}
  一个子进程执行 \texttt{ls}
\item
  \texttt{ls} 调用 \texttt{stat} (glibc)
\item
  glibc 的 \texttt{stat} 调用系统调用 \texttt{sys\_stat}
\item
  fuse 内核模块事先在 VFS 中注册了函数接口, 所以 VFS 自动将
  \texttt{stat} 请求 交由 fuse 模块处理.
\item
  fuse 模块收到 \texttt{stat} 请求, 将请求写至 \texttt{/dev/fuse}
\item
    用户文件系统守护进程 (在图 \ref{fig:fuse_structure}
    是 \texttt{hello}) 不断读取
  \texttt{/dev/fuse}, 若发现 是发送给自己的请求, 则处理该请求.
\item
  \texttt{hello} 文件系统根据用户在 \texttt{struct fuse\_operations}
  注册的回调函数, 调用 相应的 \texttt{stat} 实现.
\item
  \texttt{hello} 文件系统处理完 \texttt{stat} 请求后, 将处理结果写回给
  \texttt{/dev/fuse}
\item
  fuse 内核模块从 \texttt{/dev/fuse} 读取到 \texttt{stat}
  请求的处理结果, 将结果返回给 VFS
\item
  VFS 再将结果依次上传, 最后显示在终端中.
\end{itemize}

由此可见, fuse 内核模块负责与内核交互, 而用户文件系统通过 fuse 库, 利用
\texttt{/dev/fuse} 与 fuse 内核模块交互.

\subsection{参考资料}\label{ux53c2ux8003ux8d44ux6599}

\begin{itemize}
\item
    \url{http://fuse.sourceforge.net/doxygen/index.html}
\item
    \url{http://www.cs.nmsu.edu/~pfeiffer/fuse-tutorial/}
\end{itemize}

\section{文件系统存储与组织详细设计}\label{ux6587ux4ef6ux7cfbux7edfux5b58ux50a8ux4e0eux7ec4ux7ec7ux8be6ux7ec6ux8bbeux8ba1}

\subsection{文件系统在磁盘上的布局}\label{ux6587ux4ef6ux7cfbux7edfux5728ux78c1ux76d8ux4e0aux7684ux5e03ux5c40}

\begin{center}
\includegraphics[width=14cm]{./images/./layout.png}
\captionof{figure}{文件系统各个功能区在磁盘上的布局}
\label{fig:layout}
\end{center}

\subsection{常量说明}\label{ux5e38ux91cfux8bf4ux660e}

\begin{verbatim}
#define UFS_MAGIC           0x7594  /* 文件系统的标识 */
#define UFS_NAME_LEN        27      /* 文件名的最大长度, 不包括结尾的空字符 */
#define UFS_PATH_LEN        1024    /* 路径名最大长度, 不包括结尾的空字符 */
#define UFS_BLK_SIZE        512     /* 磁盘块大小 */
#define UFS_OPEN_MAX        64      /* 同时打开文件数最大值 */
#define UFS_DISK_MAX_SIZE   32      /* 磁盘文件最大值 (MB) */
#define UFS_DISK_MIN_SIZE   1       /* 磁盘文件最小值 (MB) */
#define UFS_ROOT_INO        1       /* 根目录的 i 结点号 */
\end{verbatim}

\subsection{主要数据结构}\label{ux4e3bux8981ux6570ux636eux7ed3ux6784}

\subsubsection{定义}\label{ux5b9aux4e49-1}

\begin{itemize}
\item
  逻辑块: 文件系统看待磁盘的方式, 文件系统分配磁盘的最小单位, 1
  个逻辑块等于 1 个磁盘块的大小. 逻辑块编号从 1 开始.
\item
  磁盘块: 访问磁盘的最小单位, 编号从 0 开始, 每一个磁盘块大小为 512
  字节.
\item
  数据块: 单个文件内部数据组成的块, 大小与逻辑块相同, 从 0 开始编号,
  数据块号仅在包含它的文件内部有效.
\end{itemize}

在外部表现上, 逻辑块与磁盘块唯一的不同在于在磁盘上的起始位置不同.
磁盘块从磁盘的第 1 块 512 字节块 就开始, 一直到磁盘的最后一块 512
字节块. 而逻辑块的第 1 块从磁盘的数据区 开始,
该磁盘块前面的几块要预留给超级块, i 结点位图, 逻辑块位图, 与 i 结点使用,
逻辑块从它们之后的第 1 块磁盘块开始,
从 1 开始编号. 在图 \ref{fig:layout} 中,
从左到右,
磁盘块从第 1 块方格开始, 而逻辑块从第 9 块方格开始.
数据块指的是分配给文件, 用来 存储文件数据 (非元数据) 的逻辑块,
如果一个文件的大小为 678 KB, 那么它就占用 2 块数据块 (不足 512 字节的也要
占用一整个数据块), 数据块号按出现顺序依次为 1, 2.

\subsubsection{文件系统超级块}\label{ux6587ux4ef6ux7cfbux7edfux8d85ux7ea7ux5757}

超级块含有整个文件系统的配置信息

\begin{verbatim}
/*
 * super block in disk.
 * sizeof(struct ufs_dsuper_block) <= 512
 */
struct ufs_dsuper_block {
    unsigned short s_magic;         /* 文件系统魔数 */
    unsigned int s_imap_blocks;     /* i 结点位图所占块数, 以逻辑块计 */
    unsigned int s_zmap_blocks;     /* 逻辑块位图所占块数, 以逻辑块计 */
    unsigned int s_inode_blocks;    /* i 结点块数, 以逻辑块计 */
    unsigned int s_zone_blocks;     /* 逻辑块块数 */
    off_t   s_max_size;             /* 最大文件长度 */
};

/* super block in memeory */
struct ufs_msuper_block {
            unsigned short s_magic;     /* 文件系统魔数 */
    unsigned int s_imap_blocks;         /* i 结点位图所占块数, 以逻辑块计 */
    unsigned int s_zmap_blocks;         /* 逻辑块位图所占块数, 以逻辑块计 */
    unsigned int s_inode_blocks;        /* i 结点块数, 以逻辑块计 */
    unsigned int s_zone_blocks;         /* 逻辑块块数 */
    off_t   s_max_size;                 /* 最大文件长度 */

    /* 下面的字段仅存在于内存中 */
    char *s_imap;                       /* i 结点位图 */
    char *s_zmap;                       /* 逻辑块位图 */
    unsigned int s_1st_inode_block;     /* 第 1 块 i 结点块的磁盘块号 */
    unsigned int s_1st_zone_block;      /* 第 1 块逻辑块的磁盘块号 */
    unsigned int    s_inode_left;       /* 剩余 i 结点数 */
    unsigned int s_block_left;          /* 剩余 逻辑块数 */
    int s_fd;                           /* 磁盘文件描述符 */
    void    *s_addr;                    /* 磁盘文件在内存中的地址 */
};
\end{verbatim}

磁盘上的超级块大小要小于 512 字节,
这是因为超级块要完全放入磁盘的第一个磁盘块中. \texttt{s\_magic}
用于唯一地识别一个文件系统, 从磁盘上加载了超级块结构后, 如果魔 数正确,
那么就可以断定这是我们想要的文件系统. \texttt{s\_max\_size} 依赖于 i
结点所 能支持的逻辑块块号数组大小, 以及逻辑块块大小, 在讲解 i
结点时会提到. \texttt{s\_zmap\_blocks}
决定了文件系统所能支持的最大磁盘大小. 假设 \texttt{s\_zmap\_blocks} 为2,
且 逻辑块大小 为 512 字节, 那么文件系统最多支持
\texttt{2 * 512 * 8 * 512 = 4 MB} 大小 的磁盘. i
结点位图的一个二进制位为 0, 表示相应的 i 结点位空闲; 为 1 则表示相应的 i
结点被占用. ``i 结点号'' 其实就 是 i 结点相应的位在位图中的下标.
逻辑块位图除了每一个位表示一个逻辑块外, 其他的与 i 结点位图相同.

\texttt{s\_imap\_blocks}, \texttt{s\_zmap\_blocks},
\texttt{s\_inode\_blocks} 与 \texttt{s\_zone\_blocks}
这四个字段需要根据磁盘文件大小动态计算. 本文件系统支持的磁盘大小在 1 MB
到 32 MB 之间, 将该区间分成三个子区间, 对每个子区间的分配策略如下
\begin{itemize}
    \item
        \texttt{1 \textless{}= size\_in\_MB \textless{}= 10}
        \begin{itemize}
            \item
                \texttt{s\_imap\_blocks = 1};
            \item \texttt{s\_zmap\_blocks = 5}; 
            \item
                \texttt{s\_inode\_blocks = 256};
        \end{itemize}
    \item
        \texttt{10 \textless{} size\_in\_MB \textless{} 21}
        \begin{itemize}
            \item
                \texttt{s\_imap\_blocks = 1}; 
            \item
                \texttt{s\_zmap\_blocks = 11};
            \item
                \texttt{s\_inode\_blocks = 512};
        \end{itemize}
    \item
        \texttt{21 \textless{}= size\_in\_MB \textless{}= 32}
        \begin{itemize}
            \item
                \texttt{s\_imap\_blocks = 2}; 
            \item
                \texttt{s\_zmap\_blocks = 16};
            \item
                \texttt{s\_inode\_blocks = 1024};
        \end{itemize}
\end{itemize}

一旦确定了前三个字段, 最后一个字段 \texttt{s\_zone\_blocks}
便很容易计算得到.

之所以分成 ``磁盘上的超级块'' 与 ``内存中的超级块''
是为了兼顾使用的方便与信息的最 小化. \texttt{struct ufs\_msuper\_block}
结构中多出来的信息可以通过 ``磁盘上的超级块'' 计算得到,
但如果每次使用时都重新计算比较浪费时间,
所以将这些辅助信息事先计算并存储起来.

为了分辨出 ``所有 i 结点都被占用'' 与 ``所有逻辑块都被占用'' 的情况, i
结点位图与 逻辑块位图的第 1 个位不用, 这样就可以通过返回 0 来表示无空闲
i 结点或 逻辑块, 在初始化文件系统时, 这两位被初始化为 1.

\subsubsection{i 结点}\label{i-ux7ed3ux70b9}

\begin{verbatim}
/*
 * 磁盘上的 i 结点.
 * sizeof(struct ufs_dinode) <= UFS_BLK_SIZE
 */
struct ufs_dinode {
    nlink_t i_nlink;    /* 链接数 */
    mode_t  i_mode;     /* 文件类型和访问权限 */
    off_t   i_size;     /* 文件长度, 以字节计 */
    time_t  i_mtime;    /* 文件内容最后一次被修改的时间 */
    time_t  i_ctime;    /* i 结点最后一次被修改的时间 */
    uid_t   i_uid;      /* 拥有此文件的用户 id */
    gid_t   i_gid;      /* 拥有此文件的用户的组 id */
    /*
     * 文件内容用到的逻辑块块号数组.
     *
     * 0-5: 直接块;
     * 6: 一次间接块
     * 7: 二次间接块
     */
    unsigned int i_zones[8];
};

/* 内存中的 i 结点. */
struct ufs_minode {
    nlink_t i_nlink;    /* 链接数 */
    mode_t  i_mode;     /* 文件类型和访问权限 */
    off_t   i_size;     /* 文件长度, 以字节计 */
    time_t  i_mtime;    /* 文件内容最后一次被修改的时间 */
    time_t  i_ctime;    /* i 结点最后一次被修改的时间 */
    uid_t   i_uid;      /* 拥有此文件的用户 id */
    gid_t   i_gid;      /* 拥有此文件的用户的组 id */
    /*
     * 文件内容用到的逻辑块块号数组.
     *
     * 0-5: 直接块;
     * 6: 间接块
     * 7: 间间接块
     */
    unsigned int i_zones[8];

    /* 下面的字段仅存在于内存中 */

     /*
      * i 结点号, 从 1 开始, 等价于与该 i 结点对应的二进制
      * 位在 i 结点位图中的下标
      */
    unsigned int    i_ino;    
    int i_refcnt;   /* i 结点被引用的次数 */
};
\end{verbatim}

\texttt{i\_nlink} 是指向该 i 结点的目录项的个数, 可用于实现硬链接.
\texttt{i\_mode} 包含了有关文件属性与 权限的信息, 该字段包含的信息如下图

\begin{center}
\includegraphics[width=15cm]{./images/./imode.png}
\captionof{figure}{文件类型与访问权限}
\label{fig:i_mode}
\end{center}

\texttt{i\_mode} 的高位在左, 低位在右. 低 9
位用于判断三类用户对该文件的读写权限, 位 9 用于判断文件类型, 其余位不用.

\begin{center}
\includegraphics[width=15cm]{./images/./i_zones_array.png}
\captionof{figure}{i 结点逻辑块块号数组的功能}
\label{fig:i_node}
\end{center}

如果存放逻辑块号的存储单元的值为 0, 说明该单元空闲.
很容易可以算出本文件系统在 32 位平台上所能支持的最大文件大小为
\texttt{(6 + 512/4 + (512/4) * (512/4)) * 512 = 8259 kB}.
\texttt{struct ufs\_minode} 结构中多出来的信息一方面是为了避免重复计算,
另一方面是为完成某些功能, 例如当 i 结点 的链接数为 0 且引用次数为 0 时,
才可删除文件并回收它占用的逻辑块与 i 结点, ``引用次数'' 指的是打开文件表
\texttt{ufs\_open\_files} 中指向该 i 结点的项数.

\subsubsection{目录项}\label{ux76eeux5f55ux9879}

\begin{verbatim}
/* sizeof(struct ufs_dir_entry) <= UFS_BLK_SIZE */
struct ufs_dir_entry {
    unsigned int    de_inum;            /* 文件的 i 结点号 */
    char    de_name[UFS_NAME_LEN + 1];  /* 文件名, 以空字符结尾 */
};
\end{verbatim}

每个目录至少含有 2 个目录项: \texttt{.} 与 \texttt{..},
文件系统格式化后只含有一个根目录, 且只有 \texttt{.} 与 \texttt{..}
这两个目录项. 目录项存放于目录文件的数据块中,
所以单个目录项的大小必须小于或等于一个数据块的大小.

\subsubsection{打开文件表}\label{ux6253ux5f00ux6587ux4ef6ux8868}

\begin{verbatim}
struct ufs_file {
    struct ufs_minode f_inode;      /* 与该文件对应的 i 结点 */
    mode_t  f_mode;                 /* 文件类型与访问权限 */
    int f_flag;                     /* 文件打开和控制标志 */
    int f_count;                    /* 对应文件句柄引用次数 */
    off_t   f_pos;                  /* 当前文件偏移量 */
};

struct ufs_file ufs_open_files[UFS_OPEN_MAX]; /* 打开文件表 */
\end{verbatim}

\texttt{ufs\_open\_files} 是文件系统存储打开文件信息的表格,
打开文件在表格中的索引将作 为文件描述符使用. \texttt{f\_mode}
字段的含义与 i 结点的 \texttt{i\_mode} 字段相同. \texttt{f\_flag}
的标志包括:
\begin{itemize}
    \item
        文件访问模式: 
        \begin{itemize}
            \item
                \texttt{O\_RDONLY}: 只读打开
            \item
                \texttt{O\_WRONLY}: 只写打开
            \item
                \texttt{O\_RDWR}: 读写打开
        \end{itemize}
    \item
        文件创建与控制标志: 
        \begin{itemize}
            \item
                \texttt{O\_APPEND}: 追加写; 
            \item
                \texttt{O\_TRUNC}:
                若打开方式包含写, 则截断文件;
        \end{itemize}
\end{itemize}

\begin{center}
\includegraphics[width=14cm]{./images/./file_mode.png}
\captionof{figure}{文件打开和控制标志, 高位在左, 低位在右}
\label{fig:f_mode}
\end{center}

3 种文件访问模式必须指定且只能指定一种, 但是文件创建与控制标志都是
可选的.

\texttt{f\_count} 表示该文件被多少个描述符引用, 例如 \texttt{dup()}
函数就可以增加 \texttt{f\_count} 的值, 当 \texttt{f\_count} 为 0 时,
该文件从打开文件表中清除, 并 将该项置为空闲状态, 表项是否空闲的依据是
\texttt{f\_count} 是否为 0.

\subsection{初始化函数}
\subsubsection[\texttt{ufs\_read\_sb}]{\texttt{int ufs\_read\_sb(const char *diskname)}}
\begin{itemize}
\item
  功能: 从磁盘上读超级块
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{diskname}: 磁盘文件名
  \end{itemize}
\item
  返回值: 成功返回 磁盘文件描述符; 失败返回 -1
\item
  注: 超级块作为文件系统的私有数据使用, 所以未在函数签名中显式给出.
  磁盘文件必须曾被 \texttt{format} 程序格式化过.
\item
  函数过程:

  \begin{itemize}
  \item
    读磁盘文件第一块磁盘块;
  \item
    检查文件系统魔数是否正确, 若正确继续读取其他字段;
  \item
    返回;
  \end{itemize}
\end{itemize}
\subsubsection[\texttt{init}]{\texttt{int init(const char *disk\_name)}}
        \begin{itemize}
\item
  功能: 文件系统运行前的初始化;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{disk\_name}: 磁盘文件名;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    成功返回 0;
  \item
    若失败终止程序;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    打开磁盘文件, 调用 \texttt{ufs\_read\_sb()} 读取超级块;
  \item
    将磁盘文件 \texttt{mmap()} 到内存;
  \item
    初始化一个 \texttt{struct ufs\_msuper\_block} 变量, 根据需要初始化
    结构体的各个成员变量;
  \item
    返回.
  \end{itemize}
  \end{itemize}
\subsection{对 i 结点操作的函数}\label{ux7cfbux7edfux8c03ux7528ux63a5ux53e3}
  \subsubsection[\texttt{ufs\_new\_inode}]{\texttt{unsigned int ufs\_new\_inode(void)}}
  \begin{itemize}
\item
  功能: 获取一个空闲的 i 结点
\item
  返回值: 若找到一个空闲的 i 结点, 返回它的 i 结点号; 否则返回 0
\item
  函数过程:

  \begin{itemize}
  \item
    从 i 结点位图的第一个位开始, 寻找第一个值为 0 的位;
  \item
    若找到值为 0 的位或超出位图范围, 退出循环;
  \item
    在循环外面, 若找到值为 0 的位, 返回它在位图中的下标, 并将该位 置 1;
    否则返回 0;
  \end{itemize}
\item
  注: 因为在格式化文件系统时, 位图的第 1 个位被设置为 1, 所以可用 0
  来指示未找到可用的 i 结点;
  \end{itemize}
  \subsubsection[\texttt{ufs\_free\_inode}]{\texttt{int ufs\_free\_inode(unsigned int inum)}}
  \begin{itemize}
\item
  功能: 释放一个指定的 i 结点
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{inum}: 将被释放的 i 结点的编号
  \end{itemize}
\item
  返回值: 若成功返回 0; 若失败返回对应的 \texttt{errno} .
  以下情况返回失败:

  \begin{itemize}
  \item
    i 节点号超出范围 返回 \texttt{-EINVAL};
  \item
    i 节点原来就处理空闲状态, 返回 \texttt{-EAGAIN};
  \end{itemize}
\end{itemize}
\subsubsection[\texttt{ufs\_rd\_inode}]{\texttt{int ufs\_rd\_inode(unsigned int inum, struct ufs\_dinode *inode)}}
\begin{itemize}
\item
  功能: 读取指定的 i 结点
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{inum}: 被读取的 i 结点的编号
  \item
    \texttt{inode}: 存放 i 结点的缓冲区
  \end{itemize}
\item
  返回值: 若成功返回 0; 失败返回对应的 \texttt{errno}. 以下情况返回失败:

  \begin{itemize}
  \item
    i 节点号超出范围, 返回 \texttt{-EINVAL}
  \item
    \texttt{inode} 为空, 返回 \texttt{-EINVAL};
  \item
    被调用函数返回错误值, 将错误值原样返回.
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{ufs\_wr\_inode}]{\texttt{int ufs\_wr\_inode(struct ufs\_minode *inode)}}
  \begin{itemize}
\item
  功能: 将指定的 i 结点写回磁盘
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{inode}: 需写回磁盘的 i 结点
  \end{itemize}
\item
  返回值: 若成功返回 0; 若失败返回 对应的 \texttt{errno}. 错误情况包括:

  \begin{itemize}
  \item
    \texttt{-EINVAL}: 输入参数不合法, 包括 \texttt{inode} 为空, i
    结点号无效;
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
  \end{itemize}

  \subsection{对块操作的函数}
  \subsubsection[\texttt{ufs\_new\_zone}]{\texttt{unsigned int ufs\_new\_zone(void)}}
  \begin{itemize}
\item
  功能: 获取一块空闲的逻辑块
\item
  返回值: 若找到一块空闲的逻辑块, 返回它的逻辑块号; 否则返回 0
\item
  注: 逻辑块用于存储文件数据 (不包括元数据), 是针对于文件系统的;
  而磁盘上 的每 512 字节为一个磁盘块, 磁盘块中可以存储任意的内容 (无论是
  i 结点, 还是 文件数据), 逻辑块的编号从 1 开始.
  \end{itemize}
  \subsubsection[\texttt{ufs\_free\_zone}]{\texttt{int ufs\_free\_zone(unsigned int zone\_num)}}
  \begin{itemize}
\item
  功能: 释放一个指定的逻辑块
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{zone\_num}: 将被释放的逻辑块块号
  \end{itemize}
\item
  返回值: 成功时返回 0; 若失败返回 \texttt{errno}. 以下情况返回失败:

  \begin{itemize}
  \item
    \texttt{zone\_num} 超出范围, 返回 \texttt{-EINVAL};
  \item
    \texttt{zone\_num} 原来就处于已释放状态, 返回 \texttt{-EAGAIN};
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{ufs\_rd\_zone}]{\texttt{int ufs\_rd\_zone(unsigned int zone\_num, void *buf, size\_t size)}}
  \begin{itemize}
\item
  功能: 读一个指定的逻辑块
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{zone\_num} :将被读取的逻辑块块号
  \item
    \texttt{buf}: 存储逻辑块数据的缓冲区
  \item
    \texttt{size}: 缓冲区大小, 必须等于逻辑块大小
  \end{itemize}
\item
  返回值: 若成功, 返回0; 若失败, 返回 \texttt{errno}. 以下情况返回失败:

  \begin{itemize}
  \item
    \texttt{zone\_num} 超出范围, 返回 \texttt{-EINVAL};
  \item
    \texttt{buf} 为空, 返回 \texttt{-EINVAL};
  \item
    \texttt{size} 不等于 逻辑块大小, 返回 \texttt{-EINVAL};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{ufs\_wr\_zone}]{\texttt{int ufs\_wr\_zone(unsigned int zone\_num, void *buf, size\_t size)}}
  \begin{itemize}
\item
  功能: 将一个指定的逻辑块写入磁盘
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{zone\_num}: 逻辑块块号
  \item
    \texttt{buf}:写入逻辑块的缓冲区
  \item
    \texttt{size}: 缓冲区大小, 必须等于逻辑块大小
  \end{itemize}
\item
  返回值: 成功返回 0; 失败返回 \texttt{errno}. 以下情况返回失败:

  \begin{itemize}
  \item
    \texttt{zone\_num} 超出范围, 返回 \texttt{-EINVAL};
  \item
    \texttt{buf} 为空, 返回 \texttt{-EINVAL};
  \item
    \texttt{size} 不等于 逻辑块大小, 返回 \texttt{-EINVAL};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{ufs\_rd\_blk}]{\texttt{int ufs\_rd\_blk(unsigned int blk\_num, void *buf, size\_t size)}}
  \begin{itemize}
\item
  功能: 从磁盘上读一块指定的磁盘块
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{blk\_num}: 将被读的磁盘块块号
  \item
    \texttt{buf}: 存储磁盘块的缓冲区
  \item
    \texttt{size}: 缓冲区大小, 必须等于磁盘块大小
  \end{itemize}
\item
  返回值: 若成功返回 0; 失败返回 \texttt{errno}. 以下情况返回失败:

  \begin{itemize}
  \item
    \texttt{blk\_num} 无效, 返回 \texttt{-EINVAL};
  \item
    \texttt{buf} 为空, 返回 \texttt{-EINVAL};
  \item
    \texttt{size} 不等于磁盘块大小, 返回 \texttt{-EINVAL};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
\item
  注: 磁盘文件上的每 512 字节都算作一个磁盘块,
  而不管该磁盘块存放的是什么 内容, 下同.
  \end{itemize}
  \subsubsection[\texttt{ufs\_wr\_blk}]{\texttt{int ufs\_wr\_blk(unsigned int blk\_num, void *buf, size\_t size)}}
  \begin{itemize}
\item
  功能: 写一块指定的磁盘块
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{blk\_num}: 将被写入的磁盘块的块号
  \item
    \texttt{buf}: 写入磁盘块的缓冲区
  \item
    \texttt{size}: 缓冲区大小, 必须等于磁盘块大小
  \end{itemize}
\item
  返回值: 若成功返回 0; 失败返回 -1, 以下情况返回失败:

  \begin{itemize}
  \item
    \texttt{blk\_num} 无效, 返回 \texttt{-EINVAL};
  \item
    \texttt{buf} 为空, 返回 \texttt{-EINVAL};
  \item
    \texttt{size} 不等于磁盘块大小, 返回 \texttt{-EINVAL};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
  \end{itemize}

  \subsection{信息转换函数}
  \subsubsection[\texttt{ufs\_inum2bnum}]{\texttt{unsigned int ufs\_inum2bnum(unsigned int inum)}}
  \begin{itemize}
\item
  功能: 计算指定的 i 结点所在的磁盘块块号
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{inum}: 待计算的 i 结点号
  \end{itemize}
\item
  返回值: 编号为 \texttt{inum} 的 i 结点所在的磁盘块块号. 若
  \texttt{inum} 无效, 返回 0.
\item
  注: 磁盘的第一个块被超级块占用, 故 0 号磁盘块不会被用到, 可用
  作指示错误的返回值.
  \end{itemize}
  \subsubsection[\texttt{ufs\_znum2bnum}]{\texttt{unsigned int ufs\_znum2bnum(unsigned int zone\_num)}}
  \begin{itemize}
\item
  功能: 计算指定的逻辑块所在的磁盘块块号
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{zone\_num}: 待计算的逻辑块块号
  \end{itemize}
\item
  返回值: 编号为 \texttt{zone\_num} 的逻辑块所在的磁盘块块号. 若
  \texttt{zone\_num} 无效则返回 0.
  \end{itemize}
  \subsubsection[\texttt{ufs\_dnum2znum}]{\texttt{unsigned int ufs\_dnum2znum(struct ufs\_minode *inode, unsigned int data\_num)}}
\begin{itemize}
\item
  功能: 计算指定的数据块所在的逻辑块号
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{inode}: 数据块所在的 i 结点指针.
  \item
    \texttt{data\_num}: 数据块号
  \end{itemize}
\item
  返回值: 若数据块号与 i 结点有效, 且数据块存在, 返回对应的逻辑块号;
  否则返回 0.
\item
  注: ``数据块'' 是相对于单个文件的, 从 1 开始编号, 数据块号最大值
  受限于 i 结点所能支持的最大文件大小.
  \end{itemize}
  \subsubsection[\texttt{ufs\_creat\_zone}]{\texttt{unsigned int ufs\_creat\_zone(struct ufs\_minode *inode, unsigned int dnum)}}
  \begin{itemize}
\item
  功能: 计算指定的数据块所在的逻辑块号, 若不存在则创建一块;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{inode}: 数据块所在的 i 结点指针;
  \item
    \texttt{dnum}: 数据块块号;
  \end{itemize}
\item
  返回值: 若数据块号与 i 结点有效, 文件大小未达到上限且磁盘有空闲逻辑块,
  则返回对应的逻辑块号; 否则返回 0.
  \end{itemize}
  \subsubsection[\texttt{ufs\_path2i}]{\texttt{int ufs\_path2i(const char *path, struct ufs\_minode *inode)}}
  \begin{itemize}
\item
  功能: 将路径名映射为 i 结点
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 被映射的路径名;
  \item
    \texttt{inode}: 存放映射后的 i 结点;
  \end{itemize}
\item
  返回值: 成功返回 0, 失败返回 \texttt{errno}, 失败包括:

  \begin{itemize}
  \item
    \texttt{path} 为空或过长, 返回 \texttt{-EINVAL};
  \item
    \texttt{inode} 为空, 返回 \texttt{-EINVAL};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
\item
  流程图 (图中未画出的判断分支都表示出错返回)\\
  \includegraphics[width=14cm]{./images/path2i.png}
  \end{itemize}
  \subsubsection[\texttt{ufs\_dir2i}]{\texttt{int ufs\_dir2i(const char *dirpath, struct ufs\_minode *dirinode)}}

  \begin{itemize}
\item
  功能: 将目录的路径名映射为对应的 i 结点;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{dirpath}: 目录的路径名;
  \item
    \texttt{dirinode}: 存放映射后的 i 结点;
  \end{itemize}
\item
  返回值: 成功返回 0, 失败返回 \texttt{errno}, 错误情况包括

  \begin{itemize}
  \item
    路径引用的文件不是一个目录文件, 返回 \texttt{-ENOTDIR};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
\item
  注: 函数过程与 \texttt{ufs\_path2i()} 非常类似, 但是将 \texttt{path}
  限制为目录文件.
  \end{itemize}
  \subsubsection[\texttt{ufs\_conv\_fmode}]{\texttt{mode\_t ufs\_conv\_fmode(mode\_t mode)}}
  \begin{itemize}
\item
  功能:
  将标准的文件类型及访问权限标志转换成本文件系统支持的文件类型及访问权限标志;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{mode}: Linux 标准的文件类型及访问权限标志;
  \end{itemize}
\item
  返回值: 本文件系统的标准文件类型与文件访问权限标志, 无出错标志.
  \end{itemize}
  \subsubsection[\texttt{ufs\_conv\_oflag}]{\texttt{int ufs\_conv\_oflag(int oflag)}}
  \begin{itemize}
\item
  功能: 将 Linux 标准的文件打开标志转换成本文件系统的打开标志;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{oflag}: Linux 标准的文件打开标志;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    本文件系统的支持的打开标志, 无出错标志;
  \end{itemize}
\end{itemize}

\subsection{操作目录项的函数}
  \subsubsection[\texttt{ufs\_find\_entry}]{\texttt{int ufs\_find\_entry(struct ufs\_minode *parent, const char *filename, struct ufs\_dir\_entry *ent)}}
  \begin{itemize}
\item
  功能: 在指定的目录中查找具有指定文件名的文件
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{parent}: 查找的位置, 必须是目录;
  \item
    \texttt{filename}: 待查找的文件名;
  \item
    \texttt{ent}: 若查找成功, 存放被查找文件的目录项
  \end{itemize}
\item
  返回值: 查找成功返回 0; 失败返回 \texttt{errno}, 失败包括:

  \begin{itemize}
  \item
    任一输入参数为空或无效, 返回 \texttt{-EINVAL};
  \item
    \texttt{parent} 不是一个目录, 返回 \texttt{-ENOTDIR};
  \item
    未找到与 \texttt{filename} 对应 的目录项, 返回 \texttt{-ENOENT};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
\item
  流程图 (图中未画出的分支都表示出错)\\
  \includegraphics[width=14cm]{./images/find_entry.png}
  \end{itemize}

  \subsubsection[\texttt{ufs\_rm\_entry}]{\texttt{int ufs\_rm\_entry(struct ufs\_minode *dir, const struct ufs\_dir\_entry *entry)}}
  \begin{itemize}
\item
  功能: 从指定的目录中移除指定的目录项;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{dir}: 在该目录中移除一个目录项;
  \item
    \texttt{entry}: 被移除的目录项;
  \end{itemize}
\item
  返回值: 移除成功返回 0; 失败返回 \texttt{errno}. 在以下情况返回失败:

  \begin{itemize}
  \item
    任一参数为空, 返回 \texttt{-EINVAL};
  \item
    \texttt{dir} 不是一个目录, 返回 \texttt{-ENOTDIR};
  \item
    目录中不存在被移除的目录项, 返回 \texttt{-ENOENT};
  \item
    目录大小与数据块数不匹配, 返回 \texttt{-EIO};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
  \end{itemize}

  \subsubsection[\texttt{ufs\_add\_entry}]{\texttt{int ufs\_add\_entry(struct ufs\_minode *dir, const struct ufs\_dir\_entry *entry)}}
  \begin{itemize}
\item
  功能: 在指定的目录中新增一个目录项
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{dir}: 在该目录中新增一个目录项;
  \item
    \texttt{entry}: 新增的目录项
  \end{itemize}
\item
  返回值: 添加成功返回 0; 失败返回 \texttt{errno}. 在以下情况返回失败：

  \begin{itemize}
  \item
    任一参数为空, 返回 \texttt{-EINVAL};
  \item
    \texttt{dir} 不是一个目录, 返回 \texttt{-ENOTDIR};
  \item
    没有磁盘空间存放目录项, 返回 \texttt{-ENOSPC};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
  \end{itemize}
  \subsection{其他帮助函数}
  \subsubsection[\texttt{ufs\_truncate}]{\texttt{int ufs\_truncate(struct ufs\_minode *iptr)}}
  \begin{itemize}
\item
  功能: 释放 i 结点占用的所有数据块
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{iptr}: 将被截断的 i 结点指针;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    成功返回 0; 失败返回 \texttt{errno}. 在以下情况返回失败:
  \item
    \texttt{iptr} 为空返回 \texttt{-EINVAL};
  \item
    被调用函数返回出错, 将错误值原样返回.
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{ufs\_is\_dirempty}]{\texttt{int ufs\_is\_dirempty(struct ufs\_minode *inode)}}

  \begin{itemize}
\item
  功能: 判断目录是否为空 (即只包含 \texttt{.} 与 \texttt{..}
  这两个目录项);
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{inode}: 目录的 i 结点;
  \end{itemize}
\item
  返回值: 若 目录只包含 \texttt{.} 与 \texttt{..} 这两个目录项, 返回 1;
  以下情况返回 0:

  \begin{itemize}
  \item
    \texttt{inode} 为空;
  \item
    \texttt{inode} 不是一个目录文件;
  \item
    \texttt{inode} 包含除了 \texttt{.} 与 \texttt{..} 之外的目录项;
  \end{itemize}
  \end{itemize}

\subsection{功能函数
(或命令)}\label{ux529fux80fdux51fdux6570-ux6216ux547dux4ee4}

\subsubsection[\texttt{format}]{\texttt{format} \textit{diskfile}}
\begin{itemize}
\item
  功能: 格式化一个文件系统
\item
  命令行参数:

  \begin{itemize}
  \item
    磁盘文件路径, 在挂载文件系统之后, 磁盘文件必须存放在另一个
    文件系统上, 否则行为是未定义的.
  \end{itemize}
\item
  程序执行结果: 由参数指定的文件被格式化成一个文件系统, 将作为磁盘使用.
\item
  注: 本文提到的磁盘都是指利用普通文件模拟的磁盘, ``普通文件''
  来源于外部 文件系统 (例如 Ext4), 磁盘作为文件系统的私有数据使用.
  一个文件或作为 磁盘使用的条件是:

  \begin{itemize}
  \item
    大小在 1 MB 到 \texttt{UFS\_DISK\_MAX\_SIZE} MB 之间
  \item
    是普通文件
  \item
    用户可读写
  \end{itemize}
\item
  函数过程

  \begin{itemize}
  \item
    打开磁盘文件;
  \item
    获取磁盘文件元数据 (主要是磁盘文件大小);
  \item
    根据磁盘文件的大小分布, 分配文件系统各个功能区的大小;
  \item
    初始化一个超级块, 并将超级块写到磁盘文件的第一个块内;
  \item
    初始化 i 结点位图与逻辑块位图, 注意这两个位图的第一个位均保留不用,
  \item
    还要预留出一个 i 结点与逻辑块给根目录使用;
  \item
    将位图写盘;
  \item
    初始化一个根目录 i 结点;
  \item
    初始化根目录 (根目录至少包含 \texttt{.} 与 \texttt{..} 这两个目录项;
  \item
    将根目录写盘;
  \item
    返回;
  \end{itemize}
\end{itemize}

\subsubsection[\texttt{creat}]{\texttt{int creat(const char *path, mode\_t mode)}}
\begin{itemize}
\item
  功能: 创建一个新文件
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 新文件的路径;
  \item
    \texttt{mode}: 新文件的访问权限.
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功, 返回只写打开的文件描述符;
  \item
    \texttt{-EACCES}: 进程无权限搜索目录; 进程无权限写新文件的父目录;
  \item
    \texttt{-EEXIST}: 新文件名已存在.
  \item
    \texttt{-EISDIR}: \texttt{path} 引用的是目录;
  \item
    \texttt{-ENAMETOOLONG}: 路径名过长或文件名过长;
  \item
    \texttt{-ENFILE}: 文件系统无空间存放新打开的文件;
  \item
    \texttt{-ENOENT}: \texttt{path} 中的某一前缀目录不存在;
  \item
    \texttt{-ENOSPC}: 硬盘空间不足;
  \item
    \texttt{-ENOTDIR}: \texttt{path} 中的某一前缀不是目录;
  \item
    \texttt{-EINVAL}: 含有无效参数;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    如果 \texttt{path} 为空, 或长度为 0, 返回 \texttt{-EINVAL};
  \item
    若 \texttt{path} 超过最大路径长度, 返回 \texttt{-ENAMETOOLONG};
  \item
    在 \texttt{ufs\_open\_files} 表中查找空闲项, 若无空闲项, 返回
    \texttt{-ENFILE}; 若找到, 记空闲项的索引为 \texttt{fd};
  \item
    调用 \texttt{parpath = dirname(path)} 与
    \texttt{base = basename(path)}, 获取前缀路径 与 新文件名;
  \item
    如果 \texttt{base} 长度超过最大文件名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    调用 \texttt{ufs\_dir2i(parpath, parinode)} 获取父目录的 i 结点,
    若函数出错, 原样返回错误值;
  \item
    调用 \texttt{ufs\_find\_entry(parinode, base, entry)},
    在父目录查找是否已存在新文件 的目录项;
  \item
    若 \texttt{ufs\_find\_entry} 的返回值为 0, 返回 \texttt{-EEXIST};
    若返回值是除了 \texttt{-ENOENT} 之外的其他值, 原样返回错误值.
  \item
    调用 \texttt{inum = ufs\_new\_inode()} 获取一个空闲的 i 结点, 若返回
    值 为0, 返回 \texttt{-ENOSPC};
  \item
    初始化一个 i 结点 \texttt{inode}, 将它的 i 结点号设置为
    \texttt{inum}, 并调用 \texttt{ufs\_wr\_inode(inode)}, 若
    \texttt{ufs\_wr\_inode} 出错, 原样返回错误值.
  \item
    初始化一个新文件的目录项 \texttt{entry}, 调用
    \texttt{ufs\_add\_entry(parinode, entry)}, 在父目录中 添加该目录项,
    若 \texttt{ufs\_add\_entry} 出错, 原样返回错误值
  \item
    用新文件的 i 结点 \texttt{inode} 初始化
    \texttt{ufs\_open\_files{[}fd{]}};
  \item
    在即将返回时, 如果前面发生了错误, 而申请过 i 结点, 则释放申请到的 i
    结点.
  \end{itemize}
\item
  注: \texttt{creat(const char *path, mode\_t mode)} 等价于
  \texttt{open(path, O\_WRONLY \textbar{} O\_CREAT \textbar{} O\_TRUNC, mode)},
  但无法通过 fuse 获取不 定参数, 故无法通过 \texttt{open} 实现
  \texttt{creat}.
\item
  流程图
  (图中未画出的判断分支都表示返回或出错返回)

  \includegraphics[width=15cm]{./images/./creat_1.png}

  \includegraphics[width=15cm]{./images/./creat_2.png}
  \end{itemize}
  \subsubsection[\texttt{release}]{\texttt{int release(const char *path, int fd)}}
  \begin{itemize}
\item
  功能: 关闭一个打开文件, 释放文件所占用的资源;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 将被释放的文件路径名, 不用;
  \item
    \texttt{fd}: 打开文件的描述符;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回 0;
  \item
    \texttt{-EBADF}: \texttt{fd} 超出有效范围, 或文件未打开;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    判断 \texttt{fd} 是否在有效范围内, 若不是, 返回 \texttt{-EBADF};
  \item
    判断 \texttt{ufs\_open\_files{[}fd{]}} 是否已打开 (即判断
    \texttt{ufs\_open\_files{[}fd{]}.f\_count} 是否非 0), 若未打开, 返回
    \texttt{-EBADF};
  \item
    \texttt{ufs\_open\_files{[}fs{]}.f\_count} 减 1;
  \item
    返回.
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{releasedir}]{\texttt{int releasedir(const char *path)}}
  \begin{itemize}
\item
  功能: 释放一个打开的目录;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 目录的路径名 (不用);
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    总是返回 0 (成功);
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    函数体无实质性内容, 直接返回 0;
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{rename}]{\texttt{int rename(const char *oldpath, const char *newpath)}}
  \begin{itemize}
\item
  功能: 改变文件的位置或 (和) 名字;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{oldpath}: 旧文件的路径;
  \item
    \texttt{newpath}: 新文件的路径;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    成功返回 0;
  \item
    \texttt{-EINVAL}: 路径名为空或长度为 0;
    或试图将某个目录重命名为它自己的子目录;
  \item
    \texttt{-EACCES}: 对 \texttt{oldpath} 或 \texttt{newpath}
    的父目录无写权限; 或者对路径 中的某一前缀目录无搜索权限; 或者
    \texttt{oldpath} 是一个目录文件, 但是对 用户对该目录无写权限
    (需要更新 \texttt{..} 目录项);
  \item
    \texttt{-EBUSY}: \texttt{oldpath} 或 \texttt{newpath} 是根目录;
  \item
    \texttt{-EISDIR}: \texttt{newpath} 是一个已存在的目录, 但是
    \texttt{oldpath} 不是一个目录 文件;
  \item
    \texttt{-ENAMETOOLONG}: \texttt{oldpath} 或 \texttt{newpath}
    长度大于最大路径名长度;
  \item
    \texttt{-ENOENT}: \texttt{oldpath} 不存在, 或 \texttt{newpath}
    中某个前缀目录部分不存在;
  \item
    \texttt{-ENOSPC}: 没有多余的空间存放新目录项;
  \item
    \texttt{-ENOTDIR}: 路径中的某一前缀目录不是一个目录文件; 或
    \texttt{oldpath} 是一 个目录文件, 但是 \texttt{newpath} 已存在,
    但不是一个目录文件;
  \item
    \texttt{-ENOTEMPTY}: \texttt{newpath} 是一个非空目录;
  \end{itemize}
\item
  流程图
  (图中未画出的分支都表示出错):

  \includegraphics[width=15cm]{./images/./rename_1.png}

  \includegraphics[width=15cm]{./images/./rename_2.png}
  \end{itemize}
  \subsubsection[\texttt{mkdir}]{\texttt{int mkdir(const char *path, mode\_t mode)}}
  \begin{itemize}
\item
  功能: 创建一个空目录;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 新目录的路径名;
  \item
    \texttt{mode}: 新目录的访问权限;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功, 返回 0;
  \item
    \texttt{-EINVAL}: \texttt{path} 为空, 或长度为 0;
  \item
    \texttt{-EACCES}: 用户对新目录的父目录无写权限, 或者,
    对路径中的某一目录 无搜索权限;
  \item
    \texttt{-EEXIST}: \texttt{path} 引用的文件 (不一定非是目录) 已存在;
  \item
    \texttt{-ENAMETOOLONG}: \texttt{path} 过长;
  \item
    \texttt{-ENOENT}: \texttt{path} 中的某个前缀目录不存在;
  \item
    \texttt{-ENOSPC}: 磁盘空间不足, 或父目录无空闲空间存放新目录项;
  \item
    \texttt{-ENOTDIR}: \texttt{path} 的某个前缀目录不是一个目录文件;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为 \texttt{NULL}, 或长度为 0, 返回
    \texttt{-EINVAL};
  \item
    若 \texttt{path} 长度大于最大路径名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    从 \texttt{path} 中分离出前缀目录与新目录名,
    \texttt{dir = dirname(path); base = basename(path)}, 若
    \texttt{base} 长度超过最大文件名长度, 返回 \texttt{-ENAMETOOLONG};
  \item
    调用 \texttt{ufs\_dir2i(dir, parent)}, 若调用出错, 原样返回错误值;
  \item
    调用 \texttt{ufs\_find\_entry(parent, base)}, 在父目录
    \texttt{parent} 中查找新目录名 \texttt{base}. 若函数返回 值是
    \texttt{0}, 返回 \texttt{-EEXIST}; 若返回值不是 \texttt{-ENOENT},
    原样返回错误值.
  \item
    调用 \texttt{ufs\_new\_inode()} 为新目录申请一个 i 结点号,
    若返回值为 0, 返回 \texttt{-ENOSPC};
  \item
    初始化新目录的 i 结点 \texttt{dirinode}, 调用
    \texttt{ufs\_add\_entry(dirinode, entry)}, 为新目录添加 两个目录项
    \texttt{.} 与 \texttt{..}, 若出错, 原样返回错误值;
  \item
    调用 \texttt{ufs\_wr\_inode(dirinode)} 将新目录的 i 结点写盘,
    若出错, 原样返回错误值;
  \item
    初始化一个新目录的目录项, 调用
    \texttt{ufs\_add\_entry(parent, entry)}, 在父目录中新增一个目录项,
    若出错, 原样返回错误值, 更新父目录的 链接数 \texttt{i\_nlink}, 调用
    \texttt{ufs\_wr\_inode(parent)} 将父 目录的 i 结点写盘; 若出错,
    原样返回错误值;
  \item
    在函数即将返回前, 检查前面的步骤是否有错误发生, 若有,
    且已经为新目录申请了 i 结点, 则将 新申请的 i 结点释放
    (\texttt{ufs\_free\_inode(newdirinode-\textgreater{}i\_ino)};
  \item
    返回.
  \end{itemize}
\item
  流程图
  (图中未画出的分支都表示出错):

  \includegraphics[width=15cm]{./images/./mkdir_1.png}

  \includegraphics[width=15cm]{./images/./mkdir_2.png}
  \end{itemize}
  \subsubsection[\texttt{readdir}]{\texttt{int readdir(const char *dirpath)}}
  \begin{itemize}
\item
  功能: 读某个目录中的所有项
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{dirpath}: 目录的路径;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功, 返回 0;
  \item
    \texttt{-ENOTDIR}: \texttt{dirpath} 引用的不是一个目录,
    或路径中的某个部分不是一个目录;
  \item
    \texttt{-ENOENT}: 路径中的某个目录不存在
  \item
    \texttt{-ENAMETOOLONG}: 路径名过长
  \item
    \texttt{-EINVAL}: 路径名为空或长度为 0;
  \item
    \texttt{-ENOMEM}: 内存不足;
  \item
    \texttt{-EIO}: 发生了一个 I/O 错误;
  \end{itemize}
\item
  函数过程

  \begin{itemize}
  \item
    若 \texttt{dirpath} 为空或长度为0, 返回 \texttt{-EINVAL};
  \item
    若 \texttt{dirpath} 长度大于最大路径名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    调用 \texttt{ufs\_dir2i(dirpath, dirinode)}, 若返回出错,
    原样返回错误值;
  \item
    循环读取 \texttt{dirinode} 所有的数据块, 对数据块 \texttt{dnum},
    调用 \texttt{ufs\_dnum2znum}, 若 返回的逻辑块号 \texttt{znum} 为 0
    而目录项还未读取完毕, 说明目录处于一种不一致的状态, 返回
    \texttt{-EIO}; 否则递增 \texttt{dnum}, 继续循环;
  \item
    调用 \texttt{ufs\_rd\_zone(znum, buf)}, 从磁盘上读取逻辑块到缓冲区
    \texttt{buf} 中; 若出错, 原样返回错误值;
  \item
    将 \texttt{buf} 当作 \texttt{struct ufs\_dir\_entry} 的数组来使用;
    若读取到一个 \texttt{buf{[}i{]}.de\_inum} 不为0 的 元素,
    则输出目录项, 并递增读取的到目录项项数.
  \item
    若所有的目录项都已读取完毕, 则退出循环.
  \item
    返回.
  \end{itemize}
  \end{itemize}

  \subsubsection[\texttt{unlink}]{\texttt{int unlink(const char *path)}}
  \begin{itemize}
\item
  功能: 删除一个目录项;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 文件的路径;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    成功返回 0;
  \item
    \texttt{-EINVAL}: 路径为空, 或长度为 0;
  \item
    \texttt{-EACCES}: 对文件的父目录无写权限,
    或对路径中的目录无搜索权限;
  \item
    \texttt{-EISDIR}: 路径名引用的是目录文件;
  \item
    \texttt{-ENAMETOOLONG}: 路径名或文件名过长;
  \item
    \texttt{-ENOENT}: 文件不存在, 或路径中的某个目录不存在;
  \item
    \texttt{-ENOTDIR}: 路径中的某一前缀目录不是一个目录文件;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为空, 或长度为 0, 返回 \texttt{-EINVAL};
  \item
    若 \texttt{path} 长度大于最大路径名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    调用 \texttt{dir = dirname(path)} 与 \texttt{file = basename(path)}
    获取路径中的目录中的目录名, 与 文件名, 若文件名过长, 则会被截断;
  \item
    调用 \texttt{ufs\_path2i(path, inode)} 获取将被删除的文件的 i 结点,
    若函数出错, 原样返回错误值;
  \item
    如果 \texttt{inode} 是一个目录文件, 返回 \texttt{-EISDIR};
  \item
    调用 \texttt{ufs\_dir2i(dir, parinode)} 获取父目录的的 i 结点,
    若函数出错, 原样返回错误值;
  \item
    调用 \texttt{ufs\_rm\_entry(parinode, entry)},
    从父目录中删除一个目录项, 若函数出错, 原样返回错误值.
  \item
    调用 \texttt{ufs\_wr\_inode(parinode)} 将父目录 i 结点写盘;
  \item
    为 \texttt{inode.i\_nlink} 减 1, 减 1 后若不为零, 调用
    \texttt{ufs\_wr\_inode(inode)} 将 i 结点写盘; 若为 0, 调用
    \texttt{ufs\_truncate(inode)} 将文件截断, 若出错, 原样返回错误值,
    截断后调用 \\
    \texttt{ufs\_free\_inode(inode.i\_ino)} 释放 i 结点.
  \item
    返回
  \end{itemize}
\item
  流程图
  (图中未画出的分支都表示出错):

  \includegraphics[width=15cm]{./images/./unlink_1.png}

  \includegraphics[width=15cm]{./images/./unlink_2.png}
  \end{itemize}
  \subsubsection[\texttt{rmdir}]{\texttt{int rmdir(const char *path)}}
  \begin{itemize}
\item
  功能: 删除一个空目录;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 目录的路径名;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    成功返回 0;
  \item
    \texttt{-EINVAL}: 目录为空, 或长度为 0;
  \item
    \texttt{-EACCES}: 对目录的父目录无写权限,
    或对路径中的目录无搜索权限;
  \item
    \texttt{-ENAMETOOLONG}: \texttt{path} 路径名过长;
  \item
    \texttt{-ENOENT}: 目录不存在, 或路径中的某个目录不存在;
  \item
    \texttt{-ENOTDIR}: \texttt{path} 引用的不是一个目录,
    或路径中的某个部分不是一个目录;
  \item
    \texttt{-ENOTEMPTY}: \texttt{path} 引用的不是一个空目录;
  \item
    \texttt{-EPERM}: \texttt{path} 引用的是根目录;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为空, 或长度为 0, 返回 \texttt{-EINVAL};
  \item
    若 \texttt{path} 长度大于最大路径名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    若 \texttt{path} 引用是根目录, 返回 \texttt{-EPERM};
  \item
    调用 \texttt{ufs\_dir2i(path, inode)}, 若函数出错, 原样返回错误值;
  \item
    如果 \texttt{inode} 不是一个目录, 返回 \texttt{-ENOTDIR};
  \item
    调用 \texttt{ufs\_is\_dirempty(inode)}, 如果目录不空, 返回
    \texttt{-ENOTEMPTY};
  \item
    调用 \texttt{dir = dirname(path)} 获取 \texttt{path} 的目录部分;
  \item
    调用 \texttt{ufs\_dir2i(dir, parinode)}, 获取父目录的 i 结点,
    若函数出错, 原样返回错误值;
  \item
    调用 \texttt{ufs\_rm\_entry(parinode, ent)}
    移除将被删除的目录的目录项, 若函数出错, 原样返回错误值;
  \item
    调用 \texttt{ufs\_wr\_inode(parinode)} 将父目录的 i 结点写盘;
  \item
    调用 \texttt{ufs\_truncate(inode)}, 释放将被删除的目录占用的数据块;
  \item
    调用 \texttt{ufs\_free\_inode(inode)}, 释放目录的 i 结点;
  \item
    返回.
  \end{itemize}
\item
  流程图
  (图中未画出的判断分支都表示返回或出错返回)

  \includegraphics[width=15cm]{./images/./rmdir_1.png}

  \includegraphics[width=15cm]{./images/./rmdir_2.png}
  \end{itemize}
  \subsubsection[\texttt{open}]{\texttt{int open(const char *path, int flag)};}
  \begin{itemize}
\item
  功能: 打开一个文件;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 文件路径;
  \item
    \texttt{flag}: 打开标志, 包括 \texttt{O\_RDWR}, \texttt{O\_RDONLY},
    \texttt{O\_WRONLY}, \texttt{O\_APPEND}, \texttt{O\_DIR},
    \texttt{O\_TRUNC};
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回非负的文件描述符;
  \item
    \texttt{-EINVAL}: \texttt{path} 为空或长度为 0;
  \item
    \texttt{-ENOTSUP}: \texttt{flag} 包含本文件系统还不支持的打开标志;
  \item
    \texttt{-ENAMETOOLONG}: \texttt{path} 长度大于最大路径名长度;
  \item
    \texttt{-EACCES}: 对文件的打开请求不被允许 (例如打开标志指定了
    \texttt{UFS\_O\_RDWR}, 但文件不可写), 或路径中的某目录 无搜索权限;
  \item
    \texttt{-EISDIR}: \texttt{path} 引用的是目录, 而打开标志包含写;
  \item
    \texttt{-ENFILE}: 文件系统无空间存放新打开的文件;
  \item
    \texttt{-ENOENT}: 文件不存在, 或路径中的某个目录不存在;
  \item
    \texttt{-ENOTDIR}: 路径中的某一前缀目录不是一个目录文件,
    或打开标志指定了 \texttt{UFS\_O\_DIR}, 但 \texttt{path}
    不是一个目录文件;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为空, 或长度为 0, 返回 \texttt{-EINVAL};
  \item
    调用 \texttt{ufs\_conv\_oflag(flag)} 将 Linux
    标准的文件打开标志转换成本文件系统的打开标志;
  \item
    若 \texttt{path} 长度大于最大路径名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    遍历 \texttt{ufs\_open\_files{[}{]}}, 寻找空闲项, 若没有空闲项, 返回
    \texttt{-ENFILE}; 若找到, 记空闲项下标为 \texttt{fd};
  \item
    调用 \texttt{ufs\_path2i(path, inode)}, 获取文件的 i 结点号,
    若函数出错, 原样返回错误值;
  \item
    若 \texttt{flag} 包含写操作 (\texttt{UFS\_O\_WRONLY},
    \texttt{UFS\_O\_RDWR} 等), 而 \texttt{path} 是一个目录文件, 返回
    \texttt{-EISDIR};
  \item
    若 \texttt{flag} 指定了 \texttt{UFS\_O\_DIR}, 但 \texttt{path}
    不是一个目录文件, 返回 \texttt{-ENOTDIR};
  \item
    若 \texttt{flag} 指定了 \texttt{UFS\_O\_TRUNC}, 则调用
    \texttt{ufs\_truncate(inode)} 与 \texttt{ufs\_wr\_inode(inode)},
    若函数出错, 原样返回错误值;
  \item
    初始化 \texttt{ufs\_open\_files{[}fd{]}} 的各个字段, 返回
    \texttt{fd};
  \end{itemize}
\item
  流程图
  (图中未画出的判断分支都表示返回或出错返回)

  \includegraphics[width=15cm]{./images/./open_1.png}

  \includegraphics[width=15cm]{./images/./open_2.png}
  \end{itemize}
  \subsubsection[\texttt{write}]{\texttt{int write(int fd, const void *buf, size\_t size, off\_t offset)}}
  \begin{itemize}
\item
  功能: 写一个文件;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{fd}: 打开文件描述符;
  \item
    \texttt{buf}: 数据缓冲区;
  \item
    \texttt{size}: 写入的数据量, 数据量大于 0;
  \item
    \texttt{offset}: 写入点的起始偏移量;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回 写入的数据量;
  \item
    \texttt{-EBADF}: \texttt{fd} 不是一个有效的文件描述符, 或没有打开,
    或打开文件时没有指定写标志;
  \item
    \texttt{-EIO}: 底层写函数出错;
  \item
    \texttt{-ENOSPC}: 磁盘空间不足;
  \item
    \texttt{-EINVAL}: \texttt{buf} 为空, 或 \texttt{size} 小于等于 0;
  \item
    \texttt{-EFBIG}: 文件过大;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{fd} 不是一个有效的文件描述符, 或没有打开,
    或打开文件时没有指定写标志, 返回 \texttt{-EBADF};
  \item
    若 \texttt{buf} 为空, 或 \texttt{size} 小于等于 0, 返回
    \texttt{-EINVAL};
  \item
    将文件的当前读写偏移量 \texttt{pos} 设置为 \texttt{offset},
    若打开文件时指定了 \texttt{UFS\_O\_APPEND}, 将 \texttt{pos}
    设置为文件的当前大小;
  \item
    当还有剩余的数据未写时, 循环;
  \item
    利用 除运算与取模运算, 计算当前要写的偏移在文件中的数据块号,
    与数据块内的偏移量; 调用 \texttt{ufs\_creat\_zone(dnum)}
    获取数据块号对应的逻辑块号, 若返回 0, 判断是否是因为文件过大, 若是,
    置 \texttt{ret = -EFBIG}; 否则置 \texttt{ret = -ENOSPC}, 退出循环;
  \item
    调用 \\
    \texttt{ufs\_rd\_zone(znum, buf)} 读一块数据,
    并将要写入的数据写入 \texttt{buf}, 再调用
    \texttt{ufs\_wr\_zone(znum, buf)} 将逻辑块写盘;
  \item
    更新文件读偏移量, 若超过文件大小, 同时更新文件 i 结点的大小, 并写盘;
  \item
    若还有数据未写完, 则继续循环, 否则退出循环;
  \item
    在循环结束后, 如果文件打开时没有设置追加写,
    则更新文件当前读写偏移量;
  \item
    若前面没有出错, 返回已写的数据量, 否则返回错误值;
  \end{itemize}
\item
  流程图
  (图中未画出的判断分支都表示返回或出错返回)

  \includegraphics[width=15cm]{./images/./write_1.png}

  \includegraphics[width=15cm]{./images/./write_2.png}
  \end{itemize}
  \subsubsection[\texttt{read}]{\texttt{int read(int fd, void *buf,
  size\_t size, off\_t offset)}}
  \begin{itemize}
\item
  功能: 读一个文件;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{fd}: 打开文件的描述符;
  \item
    \texttt{buf}: 数据缓冲区;
  \item
    \texttt{size}: 期望读到的字节数;
  \item
    \texttt{offset}: 读位置在文件中的偏移量;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回读取到的字节数, 0 表读到文件末尾;
  \item
    \texttt{-EBADF}: 文件描述符无效, 或未打开, 或打开时没有指定读标志;
  \item
    \texttt{-EIO}: 发生 I/O 错误;
  \item
    \texttt{-EISDIR}: \texttt{fd} 引用的是一个目录文件;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{fd} 无效, 或未打开, 或打开时没有指定读标志, 返回
    \texttt{-EBADF};
  \item
    若 \texttt{buf} 为空, 或 \texttt{size} 为 0, 返回 0;
  \item
    若 \texttt{ufs\_open\_files{[}fd{]}.f\_inode} 引用的是一个目录文件,
    返回 \texttt{-EISDIR};
  \item
      设置文件的当前读位置偏移量 \texttt{pos} 为 \texttt{offset}
  \item
    当未遇到文件末尾且未读满 \texttt{size} 个字节时, 循环;
  \item
    将读到的数据复制到 \texttt{buf} 中, 若出错, 原样返回错误值;
  \item
    每读完一个单元的数据, 就更新文件的当前读写偏移量.
  \item
    退出循环后, 返回读到的数据量.
  \end{itemize}
\item
  流程图
  (图中未画出的判断分支都表示返回或出错返回)

  \includegraphics[width=15cm]{./images/./read_1.png}

  \includegraphics[width=15cm]{./images/./read_2.png}
  \end{itemize}
  \subsubsection[\texttt{getattr}]{\texttt{int getattr(const char *path, struct stat *st)}}
  \begin{itemize}
\item
  功能: 获取文件的元数据;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 文件的路径;
  \item
    \texttt{st}: 存放文件元数据的缓冲区;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功, 返回 0;
  \item
    \texttt{-EINVAL}: \texttt{path} 为空, 或长度为 0, 或 \texttt{st}
    为空指针;
  \item
    \texttt{-EACCES}: 对路径中的某一目录无搜索权限;
  \item
    \texttt{-ENAMETOOLONG}: 路径过长, 或文件名过长;
  \item
    \texttt{-ENOENT}: 路径中的某一部分不存在;
  \item
    \texttt{-ENOTDIR}: 路径中的某一前缀目录不是一个目录文件;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为空, 或长度为 0, 或 \texttt{st} 是空指针, 返回
    \texttt{-EINVAL};
  \item
    调用 \texttt{ufs\_path2i(path, inode)}, 若函数出错, 原样返回错误值;
  \item
    将 \texttt{inode} 中与 Linux 兼容的字段 (\texttt{i\_ino},
    \texttt{i\_nlink}, \texttt{i\_uid}, \texttt{i\_gid},
    \texttt{i\_size}, \texttt{i\_ctime}, \texttt{i\_mtime}) 赋值给
    \texttt{st}, 并调用 \texttt{ufs\_conv\_fmode(inode.i\_mode)} 将
    文件类型及权限 (\texttt{i\_mode}) 转换为标准格式.
  \item
    返回.
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{access}]{\texttt{int access(const char *path, int mode)}}
  \begin{itemize}
\item
  功能: 按照进程的实际用户 ID 与实际组 ID 来测试文件的读写权限;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 文件的路径;
  \item
    \texttt{mode}: 需要检查的权限;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回 0;
  \item
    \texttt{-EINVAL}: \texttt{path} 为空, 或长度为 0, 或 \texttt{mode}
    包含无效参数 (除了 \texttt{F\_OK}, \texttt{R\_OK}, \texttt{W\_OK},
    \texttt{X-OK})
  \item
    \texttt{-EACCES}: 请求的权限被拒绝, 或 \texttt{path}
    中某个前缀目录不允许搜索;
  \item
    \texttt{-ENAMETOOLONG}: 路径名过长, 或文件名过长;
  \item
    \texttt{-ENOENT}: 路径中的某一部分不存在;
  \item
    \texttt{-ENOTDIR}: 路径中的某一前缀目录不是一个目录文件;
  \item
    \texttt{-EIO}: 发生了一个 I/O 错误;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为空, 或长度为 0, 返回 \texttt{-EINVAL};
  \item
    若 \texttt{mode} 包含无效参数, 返回 \texttt{-EINVAL};
  \item
    若 \texttt{path} 长度超过最大文件名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    调用 \texttt{ufs\_path2i(path, inode)}, 若函数出错, 原样返回错误值;
  \item
    若 \texttt{mode == F\_OK}, 返回 0;
  \item
    根据进程的身份, 取出与它对应的文件权限, 若 \texttt{inode.i\_mode}
    具备 \texttt{mode} 所请求的权限, 返回 0, 否则返回 \texttt{-EACCES};
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{mknod}]{\texttt{int mknod(const char *path, mode\_t mode, dev\_t dev)}}
  \begin{itemize}
\item
  功能: 创建一个普通文件;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 新文件的路径;
  \item
    \texttt{mode}: 新文件的访问权限与文件类型 (目前只支持普通文件类型);
  \item
    \texttt{dev}: 设备文件的设备号 (不用);
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回 0;
  \item
    \texttt{-EACCES}: 进程无权限搜索目录; 进程无权限写新文件的父目录;
  \item
    \texttt{-EEXIST}: 新文件名已存在.
  \item
    \texttt{-ENAMETOOLONG}: 路径名过长;
  \item
    \texttt{-ENOENT}: \texttt{path} 中的某一前缀目录不存在;
  \item
    \texttt{-ENOSPC}: 硬盘空间不足;
  \item
    \texttt{-ENOTDIR}: \texttt{path} 中的某一前缀不是目录;
  \item
    \texttt{-EINVAL}: 含有无效参数;
  \item
    \texttt{-ENOTSUP}: 请求创建的文件类型不支持;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为空, 或长度为 0, 返回 \texttt{-EINVAL};
  \item
    若 \texttt{path} 长度超过最大文件名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    若 \texttt{mode} 不是一个普通文件类型, 返回 \texttt{-ENOTSUP};
  \item
    调用 \texttt{creat(path, mode, \&fi)}, 若函数出错, 原样返回错误值;
  \item
    调用 \texttt{release(fi.fh)}, 关闭文件 (因为 \texttt{creat()}
    会打开文件);
  \end{itemize}
\item
  注: 由于文件系统目前只支持目录文件与普通文件这两种类型,
  所以现在主要通过 \texttt{creat()} 来实现 \texttt{mknod()};
  \end{itemize}
  \subsubsection[\texttt{statfs}]{\texttt{int statfs(const char *path, struct statvfs *stat)}}
  \begin{itemize}
\item
  功能: 获取文件系统的统计信息;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 文件系统内部的某个文件的路径;
  \item
    \texttt{stat}: 存放文件系统统计信息的缓冲区;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回 0;
  \item
    \texttt{-EIO}: 发生了一个 I/O 错误;
  \item
    \texttt{-EINVAL}: \texttt{path} 为空, 或长度为 0, 或 \texttt{stat}
    为空指针;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为空, 或长度为 0, 或 \texttt{stat} 为空指针, 返回
    \texttt{-EINVAL};
  \item
    从超级块中获取各种统计信息, 并赋给 \texttt{stat} 相应的字段
    (\texttt{f\_bsize}, \texttt{f\_bfree}, \texttt{f\_bavail},
    \texttt{f\_files}, \texttt{f\_ffre}, \texttt{f\_namemax});
    若获取过程中出错, 返回 \texttt{-EIO};
  \item
    返回;
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{opendir}]{\texttt{int opendir(const char *path)}}
  \begin{itemize}
\item
  功能: 打开一个目录;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 目录的路径;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回 0;
  \item
    \texttt{-EINVAL}: \texttt{path} 为空, 或长度为 0;
  \item
    \texttt{-ENAMETOOLONG}: \texttt{path} 长度超过最大文件名长度;
  \item
    \texttt{-ENOENT}: 路径中的某个目录不存在;
  \item
    \texttt{-ENOTDIR}: \texttt{path} 引用的不是一个目录,
    或路径中的某个部分不是一个目录;
  \item
    \texttt{-EACCES}: 搜索请求被拒绝;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{path} 为空, 或长度为 0, 返回 \texttt{-EINVAL};
  \item
    若 \texttt{path} 长度大于最大路径名长度, 返回
    \texttt{-ENAMETOOLONG};
  \item
    调用 \texttt{ufs\_dir2i(path, inode)}, 若函数出错, 原样返回错误值;
  \item
    返回.
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{closedir}]{\texttt{int closedir(DIR *dirp)}}
  \begin{itemize}
\item
  功能: 关闭一个打开着的目录文件;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{dirp}: 指向打开着的目录文件的指针;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回 0;
  \item
    \texttt{-EBADF}: \texttt{dirp} 的文件描述符无效;
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{dirp} 是一个空指针, 返回 \texttt{-EBADF};
  \item
    返回;
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{flush}]{\texttt{int flush(const char *path)}}
  \begin{itemize}
\item
  功能: 冲洗文件;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 被冲洗的文件路径;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    总是返回 0 (成功);
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    函数体无实质性内容, 直接返回 0;
  \end{itemize}
  \end{itemize}
  \subsubsection[\texttt{fsync}]{\texttt{int fsync(const char *path, int datasync, struct fuse\_file\_info *fi)}}

  \begin{itemize}
\item
  功能: 同步文件;
\item
  输入参数:

  \begin{itemize}
  \item
    \texttt{path}: 不用;
  \item
    \texttt{datasync}: 同步标志, 非 0 则仅同步数据; 0
    则同步数据与元数据;
  \item
    \texttt{fi}: 不用;
  \end{itemize}
\item
  返回值:

  \begin{itemize}
  \item
    若成功返回 0;
  \item
    \texttt{-EBADF}: 文件描述符无效;
  \item
    \texttt{-EIO}: 发生了一个 I/O 错误;
  \item
    \texttt{-EINVAL}: 文件不支持 同步.
  \end{itemize}
\item
  函数过程:

  \begin{itemize}
  \item
    若 \texttt{datasync} 非 0, 调用 \texttt{fdatasync(sb.s\_fd)},
    若函数出错, 返回 \texttt{-errno}; 成功返回 0;
  \item
    若 \texttt{datasync} 为 0, 调用 \texttt{fsync(sb.s\_fd)},
    若函数出错, 返回 \texttt{-errno}; 成功返回 0;
  \end{itemize}
\end{itemize}

\section{源代码}
\subsection{源代码结构}
所有的源代码 (包括文档源代码及其资源) 都放在 \verb'src/' 目录下,
该目录包含的文件或目录包括:
\begin{itemize}
    \item \verb'src/apue.h'     \\
        来自 \textit{Advanced Programming in the UNIX Environment, 3rd Edition}
        的头文件, 含有日志函数的声明及其需要包含的头文件;
    \item \verb'src/doc.tex' \\
        文档的 \LaTeX 源代码;
    \item \verb'src/error.c' \\
        错误处理函数, 来自 \textit{Advanced Programming in the UNIX
        Environment, 3rd Edition};
    \item \verb'src/errorlog.c' \\
        日志函数, 来自 \textit{Advanced Programming in the UNIX
        Environment, 3rd Edition};
    \item \verb'src/format.c' \\
        文件系统格式化程序;
    \item \verb'src/images/' \\
        生成 pdf 文档时所需的图片资源;
    \item \verb'src/tools/' \\
        测试工具程序;
    \item \verb'src/ufs.c' \\
        文件系统提供的系统调用接口, 例如 \verb'write', \verb'read' 等;
    \item \verb'src/ufs.h' \\
        文件系统的主要头文件;
    \item \verb'src/ufslib.c' \\
        文件系统向系统调用 (例如 \verb'write') 提供的功能函数 (例如 
        \verb'ufs_path2i');
\end{itemize}

\subsection{命名约定与编程风格}
\subsubsection{命名约定}
本文件系统独有的函数, 数据结构, 常量, 全局变量都冠有前缀 \verb'ufs_',
例如 \verb'ufs_write()', \verb'struct ufs_minode', \verb'UFS_ROOT_INO',
\verb'struct ufs_file ufs_open_files[]', 这么做是为了避免与系统类似的标识
符重名或冲突.
\subsubsection{编程风格}
为便于调试及分析函数调用过程, 当进入某个函数时, 打印一条日志, 日志包含有
函数的名字, 关键参数的值. 当函数调用过程中发生错误时, 打印一条日志, 内容
包括出错的函数或错误原因. 当函数返回时打印一条日志, 内容包括返回的函数名
与返回值, 例如:
\begin{verbatim}
static int ufs_getattr(const char *path, struct stat *statptr)
{
    int ret = 0;
    struct ufs_minode inode;

    log_msg("ufs_getattr called, path = %s", path == NULL ? "NULL" :
            path);
    if ((ret = ufs_path2i(path, &inode)) < 0) {
        log_msg("ufs_getattr: ufs_path2i error");
        goto out;
    }
    statptr->st_mode = ufs_conv_fmode(inode.i_mode);
    statptr->st_ino = inode.i_ino;
    statptr->st_nlink = inode.i_nlink;
    statptr->st_uid = inode.i_uid;
    statptr->st_gid = inode.i_gid;
    statptr->st_size = inode.i_size;
    statptr->st_ctime = inode.i_ctime;
    statptr->st_mtime = inode.i_mtime;
    ret = 0;
out:
    log_msg("ufs_getattr return %d", ret);
    return(ret);
}
\end{verbatim}
\section{测试与演示}\label{ux6d4bux8bd5ux4e0eux6f14ux793a}

\subsection{测试环境}\label{ux6d4bux8bd5ux73afux5883}

\begin{itemize}
\item
  Ubuntu 14.04 32-bits
\item
  fuse 2.9.4, Ubuntu 14.04 自带 fuse 开发环境.
\item
  磁盘文件 30 MB

  \begin{itemize}
  \item
    i 结点位图块数为 2 块, 可管理 \texttt{2 * 512 * 8 - 1 = 8191} 个 i
    结点;
  \item
    i 结点数据块数为 1024 块, 包含 \texttt{512 / 64 * 1024 = 8192} 个 i
    结点;
  \item
    逻辑块位图块数为 16, 可管理 \texttt{16 * 512 * 8 = 65536} 个逻辑块
    (32 MB);
  \item
    文件系统逻辑块块数为 60397 块;
  \end{itemize}
\item
  最大文件长度 8259 KB;
\item
  最大文件名长度 27 B;
\item
  带有前缀 \texttt{./} 的命令都是用户自已开发的命令, 非系统提供,
  测试者可在 \texttt{src/tools/} 目录下找到命令的源代码, 之所以要自己开发命令,
  是因为有些测试用例无法用系统提供的命令实现 (或难于实现).
\end{itemize}

\subsection{测试环境搭建}\label{ux6d4bux8bd5ux73afux5883ux642dux5efa}

\begin{itemize}
\item
  编译源码

  \texttt{\$ cd src/}\\\texttt{\$ make}
\item
  格式化文件系统
  \begin{itemize}
\item
  创建一个 30 MB 的文件, 文件名为 \texttt{disk},
  将作为文件系统的磁盘使用\\
  \texttt{dd if=/dev/zero of=disk bs=1M count=30}
\item
  格式化\\ \texttt{./format disk}
  \end{itemize}
\item
  挂载文件系统到 \texttt{mnt} 目录 (其他目录也可)\\
  \texttt{./ufs mnt disk}
\end{itemize}

现在, 用户自已编写的文件系统就开始运行了, 它挂载在 \texttt{mnt/} 目录下,
使用 \texttt{disk} 作为磁盘.

\begin{itemize}
\item
  卸载文件系统\\ \texttt{fusermount -u mnt/}
\end{itemize}

\subsection{测试内容与步骤}\label{ux6d4bux8bd5ux5185ux5bb9ux4e0eux6b65ux9aa4}

下面这些测试中出现的路径, 如果没有出现 \texttt{mnt/} 字样,
那么当前工作目录就是 在 \texttt{mnt/} 目录下,
也就是在用户实现的文件系统当中.

\subsubsection{创建文件}
\begin{itemize}
\item
  创建一个事先不存在的普通空文件 \texttt{echo > file};\\
  \includegraphics[width=14cm]{./images/./creat_t1.png}
\item
  创建一个大小达到上限的文件
  \texttt{dd if=/dev/zero of=bigest bs=1024 count=8259};\\
  \includegraphics[width=14cm]{./images/./creat_t2.png}
\item
  创建一个大小超过上限的文件
  \texttt{dd if=/dev/zero of=large bs=1M count=9};\\
  \includegraphics[width=14cm]{./images/./creat_t3.png}
\item
  创建一个已存在的文件 \texttt{echo > file\_existed};\\
  \includegraphics[width=14cm]{./images/./creat_t4.png} \\
  出现 \texttt{Function not implemented} 的原因是创建一个已存在的文件,
  会先将文件截断 (\texttt{truncate()}), 而本文件系统目前还未实现截断.
\end{itemize}
\subsubsection{创建目录}
\begin{itemize}
\item
  创建一个空目录 \texttt{mkdir emptydir};\\
  \includegraphics[width=14cm]{./images/./mkdir_t1.png}
\item
  创建一个已存在的目录 \texttt{mkdir dir\_existed};\\
  \includegraphics[width=14cm]{./images/./mkdir_t2.png}
\end{itemize}
\subsubsection{删除文件}
\begin{itemize}
\item
  删除一个已存在的文件 \texttt{rm file\_existed};\\
  \includegraphics[width=14cm]{./images/./rm_t1.png}
\item
  删除一个不存在的文件 \texttt{rm file\_not\_existed};\\
  \includegraphics[width=14cm]{./images/./rm_t2.png}
\item
  删除一个已存在的目录文件 \texttt{rm dir\_existed};\\
  \includegraphics[width=14cm]{./images/./rm_t3.png}
\end{itemize}
\subsubsection{删除目录}
\begin{itemize}
\item
  删除已存在的空目录 \texttt{rmdir dir\_empty};\\
  \includegraphics[width=14cm]{./images/./rmdir_t1.png}
\item
  删除已存在的非空目录 \texttt{rmdir dir\_nonempty};\\
  \includegraphics[width=14cm]{./images/./rmdir_t2.png}
\item
  删除不存在的目录 \texttt{rmdir dir\_noexisted};\\
  \includegraphics[width=14cm]{./images/./rmdir_t3.png}
\end{itemize}
\subsubsection{读文件}
\begin{itemize}
    \item 读一个已存在的文件 \texttt{cat file\_existed} \\
    \includegraphics[width=14cm]{./images/read_t0.png}
\item
  读一个不存在的文件 \texttt{cat file\_not\_existed};\\
  \includegraphics[width=14cm]{./images/./read_t1.png}
\item
  从偏移位置 3 读 4 个字节 \texttt{./read file\_existed 3 4};\\
  \includegraphics[width=14cm]{./images/./read_t2.png} \\
  \texttt{read} 是用户自己开发的程序, 运行时带有 3 个参数, 从左到右分别是
  被读取的文件名, 读位置在文件中的偏移量, 需要读取的字节数. ``从指定的位置
  读取指定数量的数据'' 如果用系统命令来实现会非常繁琐, 所以这里使用了用户
  自行开发的读程序 \texttt{read}.
\item
  读一个目录文件 \texttt{./read dir\_existed 0 1};\\
  \includegraphics[width=14cm]{./images/./read_t3.png}
\end{itemize}
\subsubsection{写文件}
\begin{itemize}
    \item 在文件尾端写 \verb'"wzh"': \verb'echo wzh >> file_existed' \\
        \includegraphics[width=14cm]{./images/write_t0.png}
\item
  在偏移位置 7 写 \verb'"wzh"': \texttt{./write file\_existed 7 wzh};\\
  \includegraphics[width=14cm]{./images/./write_t1.png} \\
  \texttt{write} 是用户自己开发的程序, 运行时带有 3 个参数, 从左到右分别是
  被写的文件名, 写位置在文件中的偏移量, 写入的字符串. ``从指定的位置
  写指定的数据'' 如果用系统命令来实现会非常繁琐, 所以这里使用了用户
  自行开发的写程序 \texttt{write}.
\item
  写一个不存在的文件 \texttt{./write file\_not\_existed 0 string};\\
  \includegraphics[width=14cm]{./images/./write_t2.png} \\
  如果使用 \verb'echo > file_noexisted' 或 \verb'cat > file_noexisted',
  当文件不存在时, 这两个命令会创建新文件, 这样就无法满足测试目标 (当目标
  文件不存在时, 报错).
\item
    写一个目录文件 \texttt{./write dir\_existed 0 string};\\
  \includegraphics[width=14cm]{./images/./write_t3.png}
\item
    向一个大小已达到上限的文件追加写:
  \texttt{echo >> bigest};\\
  \includegraphics[width=14cm]{./images/./write_t4.png} \\ 
  本文件系统支持的最大文件大小为 8259 kB, 即 8457216 B.
\item 覆盖写. \verb'file_existed' 原来大小为 35 字节, 从它的偏移量 30 开始,
    写 10 个字符, 写完之后, 文件大小应增长为 40 字节 (偏移量从 0 开始). \\
    \includegraphics[width=14cm]{./images/write_t5.png}
\end{itemize}
\subsubsection{写目录}
\begin{itemize}
\item
  在一个不存在的目录中创建新目录项 \texttt{mkdir dir\_noexisted/dir};\\
  \includegraphics[width=14cm]{./images/./write_dir_t1.png}
\item
  在一个已存在的目录中创建新目录项 \texttt{mkdir dir\_existed/dir};\\
  \includegraphics[width=14cm]{./images/./write_dir_t2.png}
\item
  耗尽某个目录所有的目录项. 一个目录可包含的目录项数上限为
  \texttt{8259 * 1024 / 32 = 264288}, 但用于测试的文件系统 i 结点数只有
  8192 个, 故只能通过硬链接来测试, 但本文件系统目前还 不支持硬链接,
  故无法测试;
\end{itemize}
\subsubsection{重命名}
\begin{itemize}
\item
  源文件不存在 \texttt{mv file\_not\_existed file};\\
  \includegraphics[width=14cm]{./images/./mv_t1.png}
\item
  源文件是文件, 目标不存在
  \texttt{mv file\_existed file\_not\_existed};\\
  \includegraphics[width=14cm]{./images/./mv_t2.png}
\item
  源文件是目录, 目标不存在 \texttt{mv dir\_existed dir\_noexisted};\\
  \includegraphics[width=14cm]{./images/./mv_t3.png}
\item
  源文件是文件, 目标是目录 \texttt{./mv file\_existed dir\_existed};\\
  \includegraphics[width=14cm]{./images/./mv_t4.png} \\
  在这里不能使用系统命令 \verb'mv', 因为系统提供的 \verb'mv' 会将文件
  移动到目录中, 而不是将文件重命名为目录本身, 所以这里用的是用户自行开发
  的 \verb'mv' 程序, 这个程序只调用了 \verb'rename()' 系统调用.
\item
  源文件是目录, 目标是文件 \texttt{mv dir\_existed file\_existed};\\
  \includegraphics[width=14cm]{./images/./mv_t5.png}
\item
  源文件是目录, 目标是空目录 \texttt{./mv dir\_existed dir\_empty};\\
  \includegraphics[width=14cm]{./images/./mv_t6.png} \\
  这个与下面的测试用例都不能使用系统提供的 \verb'mv' 命令, 原因同上.
\item
  源文件是目录, 目标是非空目录
  \texttt{./mv dir\_existed dir\_nonempty};\\
  \includegraphics[width=14cm]{./images/./mv_t7.png}
\item
  源文件是目录, 目标是源目录的子目录
  \texttt{mv dir\_existed dir\_existed/sub};\\
  \includegraphics[width=14cm]{./images/./mv_t8.png}
\end{itemize}
\subsubsection{极端条件测试}
\begin{itemize}
\item
  创建一个名字过长的文件 \\
  \texttt{echo > llllllllllllllllllllllllllll};

  \includegraphics[width=14cm]{./images/./name_too_long.png}
\item
  耗尽所有的 i 结点 (根结点事先占用一个 i 结点):

\begin{verbatim}
# exhausted.sh
for ((i = 0; i < 8190; i++))
do
     echo > mnt/file$i
done  
\end{verbatim}

  \includegraphics[width=14cm]{./images/./exhausted_1.png}
\end{itemize}

回忆 ``测试环境'' 一节说过的话, 虽然磁盘中共了 8192 个 i 结点, 但是 i
结点 位图只能管理 8191 个, 虽然磁盘上还剩余一个 i 结点, 但是由于没有
多余的位图空间, 因此系统也无法使用最后一个 i 结点.

\begin{itemize}
\item
  耗尽所有的逻辑块

\begin{verbatim}
# exhausted.sh
dd if=/dev/zero of=mnt/file1 bs=1024 count=8259
dd if=/dev/zero of=mnt/file2 bs=1024 count=8259
dd if=/dev/zero of=mnt/file3 bs=1024 count=8259
dd if=/dev/zero of=mnt/file4 bs=1024 count=8259  
\end{verbatim}

  \includegraphics[width=14cm]{./images/./exhausted_2.png}
\end{itemize}

\section{结语}
本文件系统实现了大部分文件系统基本功能 (读写创删), 而高级功能 (链接,
扩展属性等) 有待今后实现. 另外的一点不足之处是, 本文件系统没有考虑并
发访问, 竞争条件会给文件系统带来不可预知的后果.
\end{document}
